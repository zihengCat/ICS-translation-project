1
00:00:00,000 --> 00:00:05,016
it's all good afternoon everybody

2
00:00:01,005 --> 00:00:06,087
welcome good to see you and welcome to

3
00:00:05,016 --> 00:00:11,375
all those who are watching on videotape

4
00:00:06,087 --> 00:00:12,186
as well I want to clear up I realized

5
00:00:11,519 --> 00:00:15,990
after the last lecture that I didn't

6
00:00:13,086 --> 00:00:17,100
explain the idea of peak memory

7
00:00:15,099 --> 00:00:19,173
utilization very well to you so I want

8
00:00:18,000 --> 00:00:22,071
to just explain that it's an important

9
00:00:20,073 --> 00:00:27,114
idea and I want to make sure that that

10
00:00:22,071 --> 00:00:31,143
we have it clear so if you recall recall

11
00:00:28,014 --> 00:00:42,039
from we have we're executing a series a

12
00:00:32,043 --> 00:00:48,602
sequence of requests R 0 R 1 R 2 R K up

13
00:00:42,039 --> 00:00:55,958
to our n minus 1 and at at any point in

14
00:00:48,989 --> 00:01:03,320
time after K 1 k plus 1 requests we have

15
00:00:56,309 --> 00:01:03,320
h K which is the the heap size

16
00:01:05,159 --> 00:01:28,164
after K plus-1 requests then we have an

17
00:01:18,031 --> 00:01:32,880
e K which is the aggregate the the sum

18
00:01:28,659 --> 00:01:37,737
of all of the payloads after k plus 1

19
00:01:33,159 --> 00:01:41,920
requests okay so what we're trying to do

20
00:01:38,439 --> 00:01:45,670
with this this PK measure this aggregate

21
00:01:41,092 --> 00:01:46,159
payload is at any point in time so as we

22
00:01:45,067 --> 00:01:50,376
as we execute requests one after the

23
00:01:47,059 --> 00:01:52,147
other the sum of all the payloads in the

24
00:01:50,979 --> 00:01:56,013
heap is going to increase or decrease

25
00:01:53,047 --> 00:01:58,506
right so if we execute a and allocate

26
00:01:56,319 --> 00:02:02,355
then this the size of the payloads will

27
00:01:58,929 --> 00:02:04,005
increase if we execute a free the size

28
00:02:02,679 --> 00:02:07,720
of all those allocated payloads will

29
00:02:04,689 --> 00:02:09,750
decrease right so so as we're executing

30
00:02:07,072 --> 00:02:11,137
this the sequence of requests these the

31
00:02:10,299 --> 00:02:14,730
aggregate the sum of all the payloads is

32
00:02:12,037 --> 00:02:17,119
going to be increasing and decreasing

33
00:02:14,073 --> 00:02:19,081
okay and so what we're what we're

34
00:02:18,019 --> 00:02:21,468
capturing with the sum of all these

35
00:02:19,081 --> 00:02:23,176
payloads it's like a perfect allocator

36
00:02:21,639 --> 00:02:28,060
that has no overheads and and even more

37
00:02:24,076 --> 00:02:29,143
so one that we can where we're allowed

38
00:02:28,006 --> 00:02:33,305
to compact blocks so the sum of all of

39
00:02:30,043 --> 00:02:37,075
the the payloads is the minimum possible

40
00:02:33,359 --> 00:02:40,431
heap size or it's the minimum possible

41
00:02:37,075 --> 00:02:43,344
number of bytes required by those

42
00:02:41,079 --> 00:02:45,970
allocated blocks okay so it's very very

43
00:02:44,019 --> 00:02:47,920
aggressive and it's impossible to

44
00:02:45,097 --> 00:02:50,586
achieve but we're going to use that as

45
00:02:47,092 --> 00:02:55,179
sort of our best case okay and so to

46
00:02:51,459 --> 00:02:56,790
measure a peak

47
00:02:57,098 --> 00:03:15,137
Piku memory utilization after K plus-1

48
00:03:09,018 --> 00:03:24,084
requests which will denote U of K that's

49
00:03:16,019 --> 00:03:28,066
going to be equal to the max for all I

50
00:03:24,084 --> 00:03:27,733
less than or equal to K

51
00:03:32,045 --> 00:03:40,091
of our aggregate payloads divided by the

52
00:03:38,033 --> 00:03:44,036
size of the heap after after K plus-1

53
00:03:40,091 --> 00:03:46,139
requests okay so what what we're doing

54
00:03:44,036 --> 00:03:50,072
with this knack is we're remembering the

55
00:03:47,039 --> 00:03:53,081
high-water mark you know as our as our

56
00:03:50,072 --> 00:03:54,161
aggregate payloads increase and decrease

57
00:03:53,081 --> 00:03:57,340
we're remembering the high-water mark

58
00:03:55,061 --> 00:03:59,084
right so that was sort of the worst that

59
00:03:58,069 --> 00:04:03,097
was like the biggest set of payloads

60
00:03:59,084 --> 00:04:05,162
that we had and then so the max is

61
00:04:03,349 --> 00:04:08,416
remembering its Ramez remembering that

62
00:04:06,062 --> 00:04:10,148
high-water mark and then we're dividing

63
00:04:09,019 --> 00:04:14,510
by the total size of the heap in order

64
00:04:11,048 --> 00:04:18,107
to get an efficiency measure okay so so

65
00:04:14,051 --> 00:04:21,280
this max DK is kind of this is the best

66
00:04:19,007 --> 00:04:26,826
we could have done divided by the total

67
00:04:21,739 --> 00:04:26,754
the total heap size okay so yes

68
00:04:30,025 --> 00:04:36,038
well the allocator keeps track of of how

69
00:04:33,065 --> 00:04:38,147
big the heap is so that's pretty easy

70
00:04:36,038 --> 00:04:41,042
right so it's every time it every time

71
00:04:39,047 --> 00:04:43,088
it does every time it calls s break it's

72
00:04:41,078 --> 00:04:45,086
just that that adds to the size of the

73
00:04:43,088 --> 00:04:48,967
heap and remember we're we're assuming

74
00:04:45,086 --> 00:04:52,178
that the heat in this case is always

75
00:04:49,759 --> 00:04:55,910
increasing okay so but even if even if

76
00:04:53,078 --> 00:04:58,097
we allow the heap size to decrease could

77
00:04:55,091 --> 00:05:01,159
just if the allocator is controlling the

78
00:04:58,097 --> 00:05:03,193
size of the heap by calls to s break

79
00:05:02,059 --> 00:05:09,918
okay so is that clear

80
00:05:04,093 --> 00:05:12,982
so for UK the higher the better okay and

81
00:05:10,449 --> 00:05:17,452
for any sequence of allocates and freeze

82
00:05:13,819 --> 00:05:20,210
this max PK will be the same okay that's

83
00:05:17,479 --> 00:05:22,610
constant right

84
00:05:20,021 --> 00:05:24,080
but what varies is H of K and that

85
00:05:22,061 --> 00:05:26,137
depends on how efficient your your

86
00:05:24,008 --> 00:05:27,080
allocator is is using the heap storage

87
00:05:27,037 --> 00:05:35,206
okay

88
00:05:28,052 --> 00:05:39,143
yes question so what we're doing is at

89
00:05:35,539 --> 00:05:42,860
any point in time after after k plus 1

90
00:05:40,043 --> 00:05:44,087
requests we're about we're evaluating

91
00:05:42,086 --> 00:05:52,118
the utilization of our heap up till that

92
00:05:44,087 --> 00:05:59,376
point so it should be k 4i i less than

93
00:05:53,018 --> 00:05:59,997
or equal to k oh i'm sorry

94
00:06:10,012 --> 00:06:13,090
yeah sorry good good catch that should

95
00:06:12,004 --> 00:06:17,058
be an eye right we want to look at all

96
00:06:13,009 --> 00:06:24,081
the all the for all the requests that

97
00:06:17,094 --> 00:06:24,162
came before okay any other questions

98
00:06:26,037 --> 00:06:29,037
okay

99
00:06:35,007 --> 00:06:40,090
all right so last time we looked at some

100
00:06:37,087 --> 00:06:42,106
simple the basics of dynamic storage

101
00:06:40,009 --> 00:06:45,096
allocation a we're going to look at some

102
00:06:43,006 --> 00:06:49,012
more sophisticated techniques using

103
00:06:46,077 --> 00:06:52,132
different data structures to store the

104
00:06:49,012 --> 00:06:55,075
free list primarily we'll look at

105
00:06:53,032 --> 00:06:57,091
implicit allocators so we'll get a sort

106
00:06:55,075 --> 00:06:58,084
of a brief survey of how garbage

107
00:06:57,091 --> 00:07:02,130
collectors work and we'll just look at

108
00:06:59,065 --> 00:07:03,121
one just just one very simple kind of

109
00:07:02,949 --> 00:07:07,720
garbage collector but it'll give you an

110
00:07:04,021 --> 00:07:11,053
idea of what that means and then we'll

111
00:07:07,072 --> 00:07:12,085
finish up we'll finish up by looking at

112
00:07:11,053 --> 00:07:15,058
it at all the ways you can get yourself

113
00:07:12,085 --> 00:07:17,158
into trouble by using dynamically

114
00:07:16,003 --> 00:07:20,056
allocated storage so once once you once

115
00:07:18,058 --> 00:07:22,081
you use once you start dynamically

116
00:07:20,056 --> 00:07:25,093
allocating storage things can go really

117
00:07:22,081 --> 00:07:27,118
bad really quickly and so we'll go over

118
00:07:25,093 --> 00:07:30,612
some of those some of those bad things

119
00:07:28,018 --> 00:07:32,101
that can happen and try to alert you to

120
00:07:31,449 --> 00:07:35,460
those so you don't do them in your

121
00:07:33,001 --> 00:07:35,046
programs

122
00:07:43,069 --> 00:07:49,097
okay so we looked at how to store a free

123
00:07:47,084 --> 00:07:52,109
look free list in this sort of implicit

124
00:07:49,097 --> 00:07:54,188
form by just walking the entire heat and

125
00:07:53,009 --> 00:07:58,025
and thereby sort of being able to visit

126
00:07:55,088 --> 00:08:00,146
all the free blocks but we can do better

127
00:07:58,025 --> 00:08:03,094
if we actually have a doubly if we store

128
00:08:01,046 --> 00:08:08,090
the free bought the free list is using

129
00:08:03,319 --> 00:08:11,660
as a doubly linked list so in we call

130
00:08:08,009 --> 00:08:14,060
these explicit free lists so the idea

131
00:08:11,066 --> 00:08:18,140
with an explicit free list is that we

132
00:08:15,041 --> 00:08:21,058
put pointers we put the pointers that

133
00:08:19,004 --> 00:08:24,092
implement this the doubly linked list

134
00:08:21,058 --> 00:08:27,103
inside the the body of a free block

135
00:08:25,028 --> 00:08:30,097
where the old payload used to go so

136
00:08:28,003 --> 00:08:32,012
allocated blocks look exactly the same

137
00:08:30,349 --> 00:08:34,610
as they did the floor right there's a

138
00:08:32,012 --> 00:08:37,013
header boundary tag optional boundary

139
00:08:34,061 --> 00:08:40,139
tag splitter and then this the payload

140
00:08:37,013 --> 00:08:42,086
and any padding free blocks though the

141
00:08:41,039 --> 00:08:46,061
allocated and the allocator is not

142
00:08:42,086 --> 00:08:49,139
allowed to touch anything in the inside

143
00:08:46,061 --> 00:08:52,030
the the payload of an allocated block

144
00:08:50,039 --> 00:08:54,125
but free blocks are free right nobody's

145
00:08:52,579 --> 00:08:58,970
using them and so we the allocator can

146
00:08:55,025 --> 00:09:01,043
put the pointers that implement the data

147
00:08:58,097 --> 00:09:05,105
structure inside the what was the old

148
00:09:01,043 --> 00:09:07,127
payload so logically this is just a

149
00:09:06,005 --> 00:09:13,016
simple doubly linked list that you've

150
00:09:08,027 --> 00:09:14,126
all seen before but actually these

151
00:09:13,016 --> 00:09:19,037
things can be anywhere in memory right

152
00:09:15,026 --> 00:09:23,030
and so you know here we have we have a

153
00:09:19,037 --> 00:09:25,006
block of size six and it has a forward

154
00:09:23,003 --> 00:09:27,017
pointer that points to some other link

155
00:09:25,339 --> 00:09:29,890
and it has a backwards pointer that

156
00:09:27,044 --> 00:09:32,383
points to this block which happens to be

157
00:09:29,089 --> 00:09:36,136
have a greater memory address than than

158
00:09:32,779 --> 00:09:40,010
it okay so just the idea is you can't

159
00:09:37,036 --> 00:09:42,092
you know unless unless you make unless

160
00:09:40,001 --> 00:09:48,000
you go to great pains to maintain this

161
00:09:42,092 --> 00:09:49,501
sort of address ordered structure these

162
00:09:48,009 --> 00:09:57,620
these these blocks can be sort of

163
00:09:50,329 --> 00:10:00,350
scattered anywhere in memory oh yeah so

164
00:09:57,062 --> 00:10:02,341
this is after several you know just sort

165
00:10:00,035 --> 00:10:10,954
of indefinite number of Malik's and

166
00:10:02,899 --> 00:10:12,740
fries and yes oh yeah good question it's

167
00:10:11,269 --> 00:10:14,305
like so the question is what would

168
00:10:12,074 --> 00:10:16,603
happen if you free to a block that was

169
00:10:14,629 --> 00:10:18,860
in between two free blocks and so you

170
00:10:17,269 --> 00:10:22,910
have to coalesce it gets a little tricky

171
00:10:18,086 --> 00:10:30,185
and I'll show you in a second good now

172
00:10:22,091 --> 00:10:32,156
allocating oh yes questions so the

173
00:10:31,085 --> 00:10:35,174
question is what happens with locality

174
00:10:33,056 --> 00:10:39,080
so you still get you still get block

175
00:10:36,074 --> 00:10:44,156
locality you know use blocks are still

176
00:10:39,008 --> 00:10:48,071
contiguous so if but if if you're

177
00:10:45,056 --> 00:10:50,123
scanning sort of a set of allocated

178
00:10:49,043 --> 00:10:53,072
blocks it would be better if you could

179
00:10:51,023 --> 00:10:58,085
keep them all contiguous right that so

180
00:10:53,072 --> 00:11:02,881
it's really and so there's a you know

181
00:10:58,085 --> 00:11:04,174
that's a trade-off I don't it gets

182
00:11:03,529 --> 00:11:06,553
difficult if you think how can you

183
00:11:04,939 --> 00:11:08,870
maintain so you don't really care about

184
00:11:06,769 --> 00:11:12,805
the locality of free blocks right you're

185
00:11:08,087 --> 00:11:13,906
just walking a linked list well no I

186
00:11:13,129 --> 00:11:17,161
shouldn't say that that's if you're

187
00:11:14,689 --> 00:11:20,480
walking that list if you hit one one

188
00:11:17,449 --> 00:11:22,537
free block it would it would bring in a

189
00:11:20,048 --> 00:11:25,091
whole page so it'd be better if you were

190
00:11:23,329 --> 00:11:27,500
walking if the list you know if as much

191
00:11:25,091 --> 00:11:29,640
of that list was contained within that

192
00:11:27,005 --> 00:11:33,098
page so even that so you would benefit

193
00:11:30,459 --> 00:11:35,497
you could benefit with both allocated

194
00:11:34,043 --> 00:11:37,136
blocks because applications would be

195
00:11:35,839 --> 00:11:40,790
using them and with free blocks because

196
00:11:38,036 --> 00:11:44,068
the allocator would be walking that that

197
00:11:40,079 --> 00:11:43,168
free list so question

198
00:11:44,074 --> 00:11:51,543
we could make sense to have a program

199
00:11:48,082 --> 00:11:54,351
that effectively energy to a pre break

200
00:11:52,209 --> 00:11:57,760
so even though they only need two even

201
00:11:55,089 --> 00:11:59,560
though they only alkane into a couple of

202
00:11:57,076 --> 00:12:02,152
mono sir if you know in the future

203
00:11:59,056 --> 00:12:04,138
mentality at Domino them somehow the

204
00:12:03,052 --> 00:12:08,089
alkanes are they we're going to try to

205
00:12:05,038 --> 00:12:09,100
you can help you knowledge about it work

206
00:12:08,089 --> 00:12:10,150
that's a really good question so the

207
00:12:10,000 --> 00:12:14,011
question is could would it be possible

208
00:12:11,005 --> 00:12:16,030
for an application to sort of give hints

209
00:12:14,011 --> 00:12:18,067
to the allocator that would increase

210
00:12:16,075 --> 00:12:21,166
them improve the allocators performance

211
00:12:18,067 --> 00:12:27,070
or memory utilization the the answer you

212
00:12:22,066 --> 00:12:28,120
absolutely could but it's if you did it

213
00:12:27,007 --> 00:12:30,456
wouldn't be a general-purpose allocator

214
00:12:29,002 --> 00:12:34,009
so like malloc it's a general-purpose

215
00:12:31,149 --> 00:12:36,190
allocator so it and it provides no

216
00:12:34,027 --> 00:12:37,102
there's no option it doesn't provide any

217
00:12:36,019 --> 00:12:40,054
arguments in its interface for passing

218
00:12:38,002 --> 00:12:42,079
that information in but it absolutely if

219
00:12:40,054 --> 00:12:44,853
it had some knowledge about the future

220
00:12:42,079 --> 00:12:47,101
behavior of a program that could benefit

221
00:12:45,339 --> 00:12:49,420
right so especially I consider you

222
00:12:48,001 --> 00:12:51,055
always have this decision when you place

223
00:12:49,042 --> 00:12:53,961
an allocated block whether to split that

224
00:12:51,055 --> 00:12:57,055
block or not well if you knew that you

225
00:12:54,339 --> 00:12:59,376
were going to get a request you know for

226
00:12:57,055 --> 00:13:00,076
if you split that block and you knew

227
00:12:59,709 --> 00:13:03,700
that you're going to give requests

228
00:13:00,076 --> 00:13:04,215
coming in the future first for sizes of

229
00:13:03,007 --> 00:13:06,079
the original block then you wouldn't

230
00:13:04,899 --> 00:13:09,520
want to split it because then you would

231
00:13:07,042 --> 00:13:12,061
want it you would just keep it unsplit

232
00:13:09,052 --> 00:13:13,431
and then when you freed it then you'd

233
00:13:12,061 --> 00:13:17,100
have a block that would be the right

234
00:13:13,899 --> 00:13:19,899
size for that that future request and so

235
00:13:17,649 --> 00:13:22,662
it's you can absolutely benefit from

236
00:13:19,899 --> 00:13:24,820
that and so although you can't if

237
00:13:22,779 --> 00:13:26,770
general-purpose allocators there's no

238
00:13:24,082 --> 00:13:27,124
provision for that kind of hinting but

239
00:13:26,077 --> 00:13:30,079
there's nothing to prevent an alligator

240
00:13:28,024 --> 00:13:33,091
from doing predictions based on the the

241
00:13:30,079 --> 00:13:34,123
previous pattern of requests you know so

242
00:13:33,091 --> 00:13:36,210
if you're getting a pattern of requests

243
00:13:35,023 --> 00:13:38,122
it's alternating large block small block

244
00:13:37,029 --> 00:13:41,440
large box small block you could you

245
00:13:39,022 --> 00:13:43,024
could exploit that maybe maybe predict

246
00:13:41,044 --> 00:13:45,933
that the next request will be for a you

247
00:13:43,042 --> 00:13:47,047
know it it's the previous request is for

248
00:13:46,329 --> 00:13:49,424
a large block the next one might be for

249
00:13:47,092 --> 00:13:51,136
a small block and you could

250
00:13:50,279 --> 00:13:54,160
that's a good question any other

251
00:13:52,036 --> 00:14:08,062
questions wizard yep

252
00:13:54,016 --> 00:14:10,755
I don't know I so the question is other

253
00:14:08,062 --> 00:14:12,154
are there intelligent alligators that do

254
00:14:10,899 --> 00:14:15,160
that kind of prediction and if there are

255
00:14:13,054 --> 00:14:29,092
I don't know of them but I wouldn't I

256
00:14:15,016 --> 00:14:32,020
wouldn't say no yes question what would

257
00:14:29,092 --> 00:14:37,120
happen you end up with a free buck up a

258
00:14:32,002 --> 00:14:40,051
block just like it's just a single block

259
00:14:38,002 --> 00:14:44,026
oh so the question is what if you ended

260
00:14:40,069 --> 00:14:46,123
up with a free block that's a single

261
00:14:44,044 --> 00:14:49,075
block surrounded by two allocated blocks

262
00:14:47,023 --> 00:14:52,069
well in fact I mean that's one of the

263
00:14:49,075 --> 00:14:54,076
invariants that a good alligator has to

264
00:14:52,069 --> 00:14:56,101
maintain you should never have two

265
00:14:54,085 --> 00:14:58,138
contiguous free blocks right the

266
00:14:57,001 --> 00:15:02,017
alligator should always be coalescing as

267
00:14:59,038 --> 00:15:05,041
much as it can and if it if it does that

268
00:15:02,017 --> 00:15:06,100
coalescing is it it always does that

269
00:15:05,041 --> 00:15:10,340
coalescing then then there will never be

270
00:15:07,000 --> 00:15:19,769
two contiguous free blocks okay

271
00:15:10,709 --> 00:15:21,791
yes a question oh you'll see when we it

272
00:15:19,769 --> 00:15:25,000
comes into play when we free a block

273
00:15:22,529 --> 00:15:27,820
because you have to sort of stitch up

274
00:15:25,000 --> 00:15:32,079
when you free a block you have to sort

275
00:15:27,082 --> 00:15:33,181
of stitch up the the linked list and so

276
00:15:32,079 --> 00:15:36,640
you need both you need both pointers you

277
00:15:34,081 --> 00:15:38,089
can do it with singly linked list so in

278
00:15:36,064 --> 00:15:41,373
your in the knr book there's a an

279
00:15:38,089 --> 00:15:43,174
alligator that uses a singly linked list

280
00:15:41,949 --> 00:15:46,660
but the the disadvantages that free

281
00:15:44,074 --> 00:15:48,085
requires a search so it requires a

282
00:15:46,066 --> 00:15:52,175
search from the beginning of the list to

283
00:15:48,085 --> 00:15:52,004
find the previous block

284
00:15:54,082 --> 00:16:06,091
and there are questions these are good

285
00:15:56,041 --> 00:16:07,138
yes question okay so the question is for

286
00:16:06,091 --> 00:16:09,175
memory utilization how does the header

287
00:16:08,038 --> 00:16:13,069
and footer count towards memory

288
00:16:10,075 --> 00:16:15,151
utilization and so those those are

289
00:16:13,069 --> 00:16:17,143
overhead that decrease memory

290
00:16:16,051 --> 00:16:19,123
utilization okay because they're not

291
00:16:18,043 --> 00:16:22,117
payload so when we were computing memory

292
00:16:20,023 --> 00:16:25,105
utilization we're doing it by we're

293
00:16:23,017 --> 00:16:31,096
using the payload the aggregate payload

294
00:16:26,005 --> 00:16:34,018
to to to estimate our utilization or to

295
00:16:31,096 --> 00:16:38,127
compute our utilization so anything

296
00:16:34,018 --> 00:16:43,066
that's not payload SAR is is overhead

297
00:16:39,027 --> 00:16:48,118
one word and everything like okay was

298
00:16:43,066 --> 00:16:50,071
also one word so we had if all of our

299
00:16:49,018 --> 00:16:56,019
payloads were one word and our overhead

300
00:16:51,016 --> 00:16:56,028
was was one word then there'd be 50%

301
00:16:58,036 --> 00:17:04,067
yes if you have to book this point into

302
00:17:02,048 --> 00:17:08,123
the next and previously glossy Sony

303
00:17:04,067 --> 00:17:09,140
like whatever like every time yeah so

304
00:17:09,023 --> 00:17:12,080
the question is do you still need a

305
00:17:10,004 --> 00:17:13,100
boundary tag if you have these these

306
00:17:12,008 --> 00:17:17,009
next and previous pointers and the

307
00:17:14,036 --> 00:17:32,129
answer is yes absolutely and you'll see

308
00:17:17,009 --> 00:17:34,028
in a second why yes okay that's a really

309
00:17:33,029 --> 00:17:37,126
good question so you know what do you do

310
00:17:35,009 --> 00:17:40,076
if you have next and previous pointers

311
00:17:38,026 --> 00:17:44,033
what happens if there's a request for a

312
00:17:40,076 --> 00:17:46,097
smaller a smaller block so the answer is

313
00:17:44,096 --> 00:17:47,165
that all of those things the header the

314
00:17:46,097 --> 00:17:50,183
footer the next and previous pointers

315
00:17:48,065 --> 00:17:53,158
impose a minimum block size so if you

316
00:17:51,083 --> 00:17:58,172
have a one-word header one-word footer

317
00:17:54,058 --> 00:18:01,115
one word pre even one word next then

318
00:17:59,072 --> 00:18:03,101
you're your minimum block sizes is four

319
00:18:02,015 --> 00:18:07,019
bytes and that would be with a zero of

320
00:18:04,001 --> 00:18:09,056
zero size payload so you can never

321
00:18:07,019 --> 00:18:11,078
allocate a block smaller than your

322
00:18:09,056 --> 00:18:14,150
minimum block size so that's a very good

323
00:18:11,078 --> 00:18:18,080
very good question so it makes a

324
00:18:15,005 --> 00:18:19,070
difference right even though even though

325
00:18:18,098 --> 00:18:21,152
we're you know it looks like we're

326
00:18:20,015 --> 00:18:25,019
getting these it looks like we're

327
00:18:22,052 --> 00:18:26,117
getting these pointers here for free but

328
00:18:25,055 --> 00:18:33,068
we're not really because of this minimum

329
00:18:27,017 --> 00:18:36,086
block size requirement yep there we go

330
00:18:33,068 --> 00:18:38,099
or allocated gigantic luckily for self

331
00:18:36,086 --> 00:18:42,128
to give you specific different parts of

332
00:18:38,099 --> 00:18:44,138
that because they say one day when I'll

333
00:18:43,028 --> 00:18:49,056
get on a truck analogy since I don't

334
00:18:45,038 --> 00:18:53,043
refresh my page or it's one space so

335
00:18:49,056 --> 00:18:55,062
right but if you want to like take first

336
00:18:53,043 --> 00:18:57,132
half make them drugs take Technic and a

337
00:18:55,062 --> 00:19:03,090
certain something and if we say all of

338
00:18:58,032 --> 00:19:05,088
this up my program ridiculous like so

339
00:19:03,009 --> 00:19:08,070
it's like your movie option for that one

340
00:19:05,088 --> 00:19:12,177
which I get Nick bakas wake up yeah okay

341
00:19:09,051 --> 00:19:15,123
so the question is can you just get a

342
00:19:13,077 --> 00:19:17,088
get one large block and then split it up

343
00:19:16,023 --> 00:19:19,028
and I guess you're assuming that the

344
00:19:17,088 --> 00:19:22,146
requests would be four equally sized

345
00:19:19,073 --> 00:19:25,136
objects right so this and and that's a

346
00:19:23,046 --> 00:19:29,085
really good strategy actually so if you

347
00:19:26,036 --> 00:19:32,052
if you know or if you think that your

348
00:19:29,085 --> 00:19:33,096
workload is going to have no you can't

349
00:19:32,052 --> 00:19:35,085
do this in general-purpose allocators

350
00:19:33,096 --> 00:19:35,184
but for like a special-purpose allocator

351
00:19:35,085 --> 00:19:38,085
if you know that you're going to be

352
00:19:36,084 --> 00:19:40,143
asking for objects that are all the same

353
00:19:38,085 --> 00:19:43,122
size like compilers for example make

354
00:19:41,043 --> 00:19:46,086
maintain abstract syntax trees and

355
00:19:44,022 --> 00:19:50,055
they're allocating nodes dynamically and

356
00:19:46,086 --> 00:19:51,114
those nodes are the same size so if you

357
00:19:50,055 --> 00:19:54,137
can you can exploit that by just

358
00:19:52,014 --> 00:19:57,018
allocating a large chunk and then

359
00:19:55,037 --> 00:19:59,100
allocating all the objects of that size

360
00:19:57,054 --> 00:20:01,089
out of that chunk it's very efficient

361
00:20:00,000 --> 00:20:04,017
you don't even need pointers or anything

362
00:20:01,089 --> 00:20:05,094
all you need is a bit vector to tell you

363
00:20:04,017 --> 00:20:08,034
which chunks are allocated in which

364
00:20:05,094 --> 00:20:09,101
chunks are free and then and you also as

365
00:20:08,034 --> 00:20:12,111
a side-effect you'll get that contiguous

366
00:20:10,064 --> 00:20:16,140
that contiguous access so if a program

367
00:20:13,011 --> 00:20:19,011
access those those objects like to be

368
00:20:17,004 --> 00:20:20,022
part of a linked list there was

369
00:20:19,011 --> 00:20:25,052
something that it was going to traverse

370
00:20:20,058 --> 00:20:26,060
you could allocate those in order and

371
00:20:25,052 --> 00:20:28,107
contiguously

372
00:20:26,078 --> 00:20:30,107
now with with a general-purpose

373
00:20:29,007 --> 00:20:37,019
allocator where you don't really know

374
00:20:31,007 --> 00:20:37,019
what's going to be requested it's

375
00:20:39,051 --> 00:20:43,102
ASL is a sector insulting absolutely you

376
00:20:42,097 --> 00:20:45,124
could do that you can make general

377
00:20:44,002 --> 00:20:47,061
assumptions about the sort of behavior

378
00:20:46,024 --> 00:20:50,032
of your programs and you know you could

379
00:20:47,061 --> 00:20:51,070
you could run traces or like in the case

380
00:20:50,032 --> 00:20:54,121
of malok lab you could look at the

381
00:20:51,007 --> 00:20:57,106
traces but that's no that's a really

382
00:20:55,021 --> 00:21:01,740
good thing you know you can't you're you

383
00:20:58,069 --> 00:21:03,076
can't just like do if statements to say

384
00:21:01,929 --> 00:21:06,600
well if the size is 42 and then the next

385
00:21:04,039 --> 00:21:08,128
size is 24 then I know it's this trace

386
00:21:06,006 --> 00:21:11,011
okay but you can look at a trace and say

387
00:21:09,028 --> 00:21:13,123
there's an interesting pattern here I'm

388
00:21:12,001 --> 00:21:15,073
going to account for that pattern I'm

389
00:21:14,023 --> 00:21:17,065
going to optimize for that pattern and

390
00:21:15,082 --> 00:21:18,127
that that would just and that's

391
00:21:17,065 --> 00:21:20,140
perfectly valid that's just like taking

392
00:21:19,027 --> 00:21:25,086
advantage of your workload right that's

393
00:21:21,004 --> 00:21:25,050
what we do in systems all the time yeah

394
00:21:29,004 --> 00:21:41,097
can we divided up our data which is

395
00:21:38,074 --> 00:21:41,097
stored in some other party

396
00:21:42,669 --> 00:21:47,682
Oh Oh so the question is why can't we

397
00:21:45,359 --> 00:21:49,422
why can't we sort of have separate areas

398
00:21:47,799 --> 00:21:55,830
of the heap for the pointers and the

399
00:21:49,989 --> 00:22:01,068
payloads all right join them up with

400
00:21:56,109 --> 00:22:03,162
pointers oh why not

401
00:22:01,779 --> 00:22:06,820
okay so the question is why not why

402
00:22:03,639 --> 00:22:09,654
can't we split up payloads and link them

403
00:22:06,082 --> 00:22:11,031
together with pointers the answer is

404
00:22:09,789 --> 00:22:14,590
that the applications expecting a

405
00:22:11,769 --> 00:22:17,950
contiguous block you can't allocate or

406
00:22:14,059 --> 00:22:19,338
can't put anything in the payload it all

407
00:22:17,095 --> 00:22:21,534
I can do all it's allowed to do is

408
00:22:19,869 --> 00:22:24,820
return a contiguous block of the size of

409
00:22:22,389 --> 00:22:28,401
the application requested and after once

410
00:22:24,082 --> 00:22:32,751
it does that it can't touch it okay all

411
00:22:28,509 --> 00:22:36,070
right good good all right so let's look

412
00:22:33,489 --> 00:22:38,514
at how we'd allocate and free once if we

413
00:22:36,007 --> 00:22:41,616
have this this explicit list how we

414
00:22:38,739 --> 00:22:45,744
would allocate and free block so

415
00:22:41,679 --> 00:22:48,711
allocating is pretty simple we'll have

416
00:22:45,789 --> 00:22:52,791
so here's our sort of a graphic of our

417
00:22:48,999 --> 00:22:55,960
free list so we have forward pointers

418
00:22:52,809 --> 00:22:56,883
and backward pointers and the idea is we

419
00:22:55,096 --> 00:23:03,795
want to allocate out of this middle

420
00:22:57,549 --> 00:23:08,586
block so we allocate the block of the

421
00:23:04,659 --> 00:23:10,704
size that we need and then we just

422
00:23:08,919 --> 00:23:15,190
update the forward and back pointers of

423
00:23:11,109 --> 00:23:18,940
the previous and next blocks to point to

424
00:23:15,019 --> 00:23:20,110
this new free block okay so that's

425
00:23:18,094 --> 00:23:26,183
pretty simple we're just we're updating

426
00:23:21,001 --> 00:23:26,930
one two three four five six six pointers

427
00:23:28,044 --> 00:23:33,115
okay now give us it gets trickier when

428
00:23:31,003 --> 00:23:37,057
we have to free because because we

429
00:23:34,015 --> 00:23:40,080
require coalescing so when you free a

430
00:23:37,084 --> 00:23:42,097
block that that was previously allocated

431
00:23:40,008 --> 00:23:44,014
the question is what do you do with that

432
00:23:42,097 --> 00:23:46,116
free block right it wasn't in the free

433
00:23:44,086 --> 00:23:48,154
list because it was an allocated block

434
00:23:47,016 --> 00:23:51,019
so now that you've freed the block where

435
00:23:49,054 --> 00:23:54,073
do you put it as you've got to put it

436
00:23:51,046 --> 00:23:56,119
somewhere so that the simplest thing is

437
00:23:54,073 --> 00:23:58,105
this life--all policy so the simplest

438
00:23:57,019 --> 00:24:01,072
thing is just put it at the beginning of

439
00:23:59,005 --> 00:24:04,087
the list so the last block freed is the

440
00:24:01,072 --> 00:24:08,073
first block allocated if it's it's okay

441
00:24:04,087 --> 00:24:10,099
so that's so-called like oh now this is

442
00:24:08,082 --> 00:24:11,125
simple because you're always doing the

443
00:24:10,099 --> 00:24:13,183
same thing you're just putting the block

444
00:24:12,025 --> 00:24:16,051
at the beginning the list and it's

445
00:24:14,083 --> 00:24:19,171
constant time you're just updating a few

446
00:24:16,051 --> 00:24:23,089
pointers okay but the study suggests

447
00:24:20,071 --> 00:24:25,123
that the the fragmentation can be worse

448
00:24:23,089 --> 00:24:27,168
than the alternative technique which is

449
00:24:26,023 --> 00:24:32,029
to keep the blocks ordered by address

450
00:24:28,068 --> 00:24:33,163
okay so when uh if you if you if you

451
00:24:32,083 --> 00:24:36,171
choose this address ordered policy when

452
00:24:34,063 --> 00:24:39,109
you when you free an allocated block

453
00:24:37,071 --> 00:24:41,122
you're going to somehow figure out

454
00:24:40,009 --> 00:24:44,086
you're going to somehow place that block

455
00:24:42,022 --> 00:24:47,023
in the list so that the previous block

456
00:24:44,086 --> 00:24:49,102
begins at a smaller address and the next

457
00:24:47,023 --> 00:24:51,061
block begins at a larger address right

458
00:24:50,002 --> 00:24:54,037
so this generally involves some kind of

459
00:24:51,061 --> 00:24:56,077
search right you don't you're just given

460
00:24:54,037 --> 00:24:58,045
this allocated block and then somehow

461
00:24:56,077 --> 00:24:59,164
you've got and you know its address and

462
00:24:58,045 --> 00:25:03,121
so now you've got to somehow search the

463
00:25:00,064 --> 00:25:06,091
the free list to find the you know the

464
00:25:04,021 --> 00:25:08,059
proper place to insert it now I suppose

465
00:25:06,091 --> 00:25:09,169
you could do better if you had some kind

466
00:25:08,059 --> 00:25:12,127
of so if you could speed up that search

467
00:25:10,069 --> 00:25:16,072
with some kind of balance tree that

468
00:25:13,027 --> 00:25:18,055
would be one option right but then that

469
00:25:16,072 --> 00:25:20,149
the problem we always run into with

470
00:25:18,055 --> 00:25:22,132
balance trees and usually is one student

471
00:25:21,049 --> 00:25:24,097
at lea somebody always tries to

472
00:25:23,032 --> 00:25:26,059
implement malloc with a some kind of

473
00:25:24,097 --> 00:25:29,170
balance tree red-black tree or something

474
00:25:26,059 --> 00:25:32,098
and it seems like a really good idea but

475
00:25:30,007 --> 00:25:36,058
you have to realize that you're you're

476
00:25:32,098 --> 00:25:39,124
competing with with other techniques

477
00:25:37,021 --> 00:25:42,100
specifically segregated lists that are

478
00:25:40,024 --> 00:25:45,813
very fast and have very small constant

479
00:25:43,000 --> 00:25:48,046
factors and there's even though even

480
00:25:46,029 --> 00:25:51,460
though ordered lists are I think it's

481
00:25:48,046 --> 00:25:54,097
usually n log in to update an order tree

482
00:25:51,046 --> 00:25:56,095
upon your ordered tree that constant

483
00:25:54,097 --> 00:25:58,926
factors can be can be quite large and so

484
00:25:56,095 --> 00:26:02,424
usually get nailed up with the constant

485
00:25:59,799 --> 00:26:04,836
factors of maintaining the tree and you

486
00:26:03,279 --> 00:26:08,380
don't get help that the search time is

487
00:26:05,169 --> 00:26:13,233
log n but as we'll see with segregated

488
00:26:08,038 --> 00:26:15,097
lists in the in the limit as in the

489
00:26:13,809 --> 00:26:18,850
limit as the number of different size

490
00:26:15,097 --> 00:26:20,119
classes increases the the search time

491
00:26:18,085 --> 00:26:22,914
approaches constant time and if you if

492
00:26:21,019 --> 00:26:25,608
you have size classes that cover ranges

493
00:26:23,679 --> 00:26:28,210
of powers of two then the search time

494
00:26:25,779 --> 00:26:31,000
reduces to a long time anyway because

495
00:26:28,021 --> 00:26:36,480
the the size of each classes are now

496
00:26:31,000 --> 00:26:40,033
logarithmic the log so you know I would

497
00:26:36,669 --> 00:26:41,694
suggest done you know just doing a

498
00:26:40,033 --> 00:26:44,382
simple thing usually whenever you're

499
00:26:41,919 --> 00:26:46,360
you're dealt with sort of large design

500
00:26:44,679 --> 00:26:48,970
space like malakut you're better off

501
00:26:46,036 --> 00:26:50,325
doing the simple thing and then

502
00:26:48,097 --> 00:26:53,166
optimizing only when you see that

503
00:26:50,649 --> 00:26:56,320
there's that you need to optimize okay

504
00:26:54,039 --> 00:26:58,840
so remember last time we talked about

505
00:26:56,032 --> 00:27:01,069
this trick to to eliminate the boundary

506
00:26:58,084 --> 00:27:02,152
tag footer and allocated blocks that's

507
00:27:01,069 --> 00:27:07,150
an example of an optimization you should

508
00:27:03,052 --> 00:27:09,145
defer so that wait you know wait get do

509
00:27:08,005 --> 00:27:14,041
the simple thing and then try to improve

510
00:27:10,045 --> 00:27:16,111
incrementally by int by you know there's

511
00:27:14,086 --> 00:27:20,101
just this optimization or another

512
00:27:17,011 --> 00:27:22,075
optimization so there's this phenomena

513
00:27:21,001 --> 00:27:24,037
of a lot of lot of programmers make a

514
00:27:22,075 --> 00:27:26,244
mistake of what we call premature

515
00:27:24,037 --> 00:27:28,099
optimization so try to think of all the

516
00:27:26,919 --> 00:27:30,480
fancy things they can do and then they

517
00:27:28,099 --> 00:27:31,788
put all those in at the beginning and

518
00:27:30,048 --> 00:27:32,146
before they even know that it needs to

519
00:27:32,679 --> 00:27:36,070
be optimized

520
00:27:33,046 --> 00:27:38,101
okay so D so the way you want to work on

521
00:27:36,007 --> 00:27:42,022
this and any any sort of complex problem

522
00:27:39,001 --> 00:27:44,002
like like an alligator is to you know

523
00:27:42,022 --> 00:27:46,051
first do fairly simple things and then

524
00:27:44,002 --> 00:27:48,651
look and see where where the slowdowns

525
00:27:46,051 --> 00:27:48,138
are inefficiencies are and then just

526
00:27:48,669 --> 00:27:51,180
sort of

527
00:27:49,038 --> 00:27:52,071
hit those one after the other and

528
00:27:51,018 --> 00:27:55,089
optimize only for the things that are

529
00:27:52,071 --> 00:28:01,086
necessary and this is a good example of

530
00:27:55,089 --> 00:28:09,102
that okay now to get to your question

531
00:28:01,086 --> 00:28:10,167
about freeing freeing is tough because

532
00:28:10,002 --> 00:28:13,020
we always have to do this coalescing

533
00:28:11,067 --> 00:28:16,125
right because of this invariant that we

534
00:28:13,002 --> 00:28:19,089
can never have to free blocks to

535
00:28:17,025 --> 00:28:21,108
adjacent free blocks so let's go through

536
00:28:20,007 --> 00:28:23,079
each of those four cases that we went

537
00:28:22,008 --> 00:28:28,044
over last time and see how we would do

538
00:28:23,079 --> 00:28:30,174
it now that we have this just this

539
00:28:28,044 --> 00:28:33,141
explicit free list so here we have the

540
00:28:31,074 --> 00:28:36,075
root of our free list pointing to the

541
00:28:34,041 --> 00:28:38,139
first block in the free list there's a

542
00:28:36,084 --> 00:28:40,110
null back pointer and then that there's

543
00:28:39,039 --> 00:28:43,080
a null pre pointer and then the next

544
00:28:41,001 --> 00:28:47,028
next pointer points to some unspecified

545
00:28:43,008 --> 00:28:48,087
block and so we have this yellow block

546
00:28:47,037 --> 00:28:51,093
which is allocated and now the

547
00:28:49,059 --> 00:28:52,140
application is called free free with a

548
00:28:51,093 --> 00:28:56,097
pointer that points the beginning of

549
00:28:53,004 --> 00:28:58,071
this block so what do we do well this

550
00:28:57,033 --> 00:29:01,041
case is pretty simple because there's no

551
00:28:59,007 --> 00:29:06,014
coalescing because both the predecessor

552
00:29:02,013 --> 00:29:10,044
and successor blocks are are allocated

553
00:29:06,077 --> 00:29:11,109
okay so we just this newly freed block

554
00:29:10,044 --> 00:29:13,140
now becomes we're going to do a LIFO

555
00:29:12,009 --> 00:29:17,043
policy so this becomes the first block

556
00:29:14,004 --> 00:29:19,008
in the free list and so we update the

557
00:29:17,043 --> 00:29:21,090
route to point to this this newly freed

558
00:29:19,008 --> 00:29:22,086
block and we update the forward pointer

559
00:29:21,009 --> 00:29:26,060
of that block to point to what used to

560
00:29:23,058 --> 00:29:26,141
be the first block in the heap

561
00:29:29,000 --> 00:29:36,012
now I'm going to be careful it's a

562
00:29:33,048 --> 00:29:38,145
little bit confusing because we've got

563
00:29:36,012 --> 00:29:42,033
sort of two notions of like previous and

564
00:29:39,045 --> 00:29:44,051
next right there's the you know given

565
00:29:42,033 --> 00:29:47,061
some given some block

566
00:29:44,051 --> 00:29:50,073
there's the predecessor block in memory

567
00:29:47,061 --> 00:29:51,126
which may or may not be allocated or

568
00:29:50,073 --> 00:29:54,165
free right it may or may not be in a

569
00:29:52,026 --> 00:29:57,048
free list and there's a successor block

570
00:29:55,065 --> 00:30:01,131
okay so we'll use predecessor and

571
00:29:57,048 --> 00:30:05,049
successor to distinguish adjacency in

572
00:30:02,031 --> 00:30:07,125
memory okay and we'll use pre even next

573
00:30:05,058 --> 00:30:13,071
to denote adjacency in the free list

574
00:30:08,025 --> 00:30:15,099
okay so this this block is the next

575
00:30:13,071 --> 00:30:19,088
block for the current block and it has

576
00:30:15,099 --> 00:30:18,188
no previous block okay

577
00:30:20,029 --> 00:30:26,053
all right now what about case to number

578
00:30:22,054 --> 00:30:29,092
case to the predecessor block is free

579
00:30:26,053 --> 00:30:32,134
and the successor block is is allocated

580
00:30:29,092 --> 00:30:37,120
and now we want to free this what was an

581
00:30:33,034 --> 00:30:41,062
allocated block denoted by yellow and we

582
00:30:38,002 --> 00:30:43,006
have this this successor this

583
00:30:41,062 --> 00:30:45,157
predecessor block is part of the free

584
00:30:43,024 --> 00:30:48,028
list right so it has it has previous and

585
00:30:46,057 --> 00:30:50,149
next blocks that are just part of the

586
00:30:48,064 --> 00:30:52,093
free list and so our route points to the

587
00:30:51,049 --> 00:30:56,104
first block in the list and then

588
00:30:52,093 --> 00:30:58,156
eventually you get to this free block

589
00:30:57,004 --> 00:31:02,092
which points to this free block which

590
00:30:59,056 --> 00:31:05,083
points to this free block okay so what

591
00:31:02,092 --> 00:31:08,143
we have to do then is we have to

592
00:31:05,083 --> 00:31:12,088
coalesce these two these two blocks into

593
00:31:09,043 --> 00:31:14,086
one big free block okay and then we have

594
00:31:12,088 --> 00:31:19,150
to splice it out and stick it at the

595
00:31:14,086 --> 00:31:20,098
beginning of the list okay so what that

596
00:31:20,005 --> 00:31:24,013
looks like

597
00:31:20,098 --> 00:31:26,140
conceptually is we we we coalesce these

598
00:31:25,003 --> 00:31:32,064
two blocks now to form this one free

599
00:31:27,004 --> 00:31:35,080
block and then we splice it out by

600
00:31:32,091 --> 00:31:38,092
having what was the what was its

601
00:31:36,016 --> 00:31:40,021
previous block now point to what used to

602
00:31:38,092 --> 00:31:45,117
be the next block okay

603
00:31:40,066 --> 00:31:45,117
fix of the current block okay so this

604
00:31:46,008 --> 00:31:52,012
the pointer from this block now points

605
00:31:50,041 --> 00:31:54,049
to this block okay and then the so we've

606
00:31:53,002 --> 00:31:58,009
effectively spliced that that current

607
00:31:55,021 --> 00:32:00,022
block out of the free list and then the

608
00:31:58,027 --> 00:32:02,056
root we have the root point to that

609
00:32:00,031 --> 00:32:04,038
block so that's now the new first block

610
00:32:02,056 --> 00:32:04,101
of the list

611
00:32:07,002 --> 00:32:11,026
okay and then we have to update what

612
00:32:09,067 --> 00:32:14,074
used to be the first block in the list

613
00:32:11,026 --> 00:32:18,115
so now it points back to the the newly

614
00:32:14,074 --> 00:32:24,151
freed coalesce block so that cleared

615
00:32:19,015 --> 00:32:27,028
everybody its yep so with the rupiah

616
00:32:25,051 --> 00:32:31,060
global variable it could be or it could

617
00:32:27,028 --> 00:32:32,083
be there's there's two ways to do this

618
00:32:31,006 --> 00:32:37,012
right it could just be a global variable

619
00:32:32,083 --> 00:32:39,160
or it could be a it could be a struct

620
00:32:38,002 --> 00:32:42,019
that of like previous the next pointer

621
00:32:40,006 --> 00:32:43,063
so sometimes it's easier if you keep the

622
00:32:42,037 --> 00:32:45,112
same you know when you're doing linked

623
00:32:44,017 --> 00:32:47,080
lists that the route if you just make it

624
00:32:46,012 --> 00:32:49,078
the same as all the other nodes it can

625
00:32:47,008 --> 00:32:50,104
simplify things but yeah it could be a

626
00:32:49,078 --> 00:32:59,104
global variable global scalar in the

627
00:32:51,076 --> 00:33:00,160
allocator okay so case oh now one thing

628
00:33:00,004 --> 00:33:05,026
one thing that comes to mind there is

629
00:33:01,006 --> 00:33:09,085
like there is an optimization that we

630
00:33:05,026 --> 00:33:13,075
could do in this case do you see when we

631
00:33:10,039 --> 00:33:15,112
when we coalesce we could just leave

632
00:33:13,075 --> 00:33:18,082
that block right there in the free list

633
00:33:16,012 --> 00:33:20,020
right we did although I believe adopted

634
00:33:18,082 --> 00:33:23,154
so the examples I'm going to show you

635
00:33:20,092 --> 00:33:26,101
are assuming a LIFO policy for insertion

636
00:33:24,054 --> 00:33:28,120
we could just leave it there right that

637
00:33:27,001 --> 00:33:31,003
and just don't update anything just

638
00:33:29,002 --> 00:33:33,010
increase create this newly coalesce

639
00:33:31,021 --> 00:33:35,047
block and then mentally we don't require

640
00:33:34,000 --> 00:33:38,008
in this case we wouldn't require any

641
00:33:35,047 --> 00:33:39,135
free list manipulation okay but that

642
00:33:38,008 --> 00:33:42,093
would be that would be one of these

643
00:33:40,035 --> 00:33:43,038
optimizations right

644
00:33:43,094 --> 00:33:50,162
now case three if you recall is the case

645
00:33:49,004 --> 00:33:54,043
where the the predecessor block is

646
00:33:51,062 --> 00:33:57,079
allocated and the successor block is

647
00:33:54,079 --> 00:33:57,079
freed

648
00:34:00,038 --> 00:34:05,069
the successor block is free so in this

649
00:34:04,309 --> 00:34:08,335
case what we have to do is we have to

650
00:34:05,069 --> 00:34:12,131
create we have to coalesce the newly

651
00:34:08,569 --> 00:34:16,573
freed block with the with the successor

652
00:34:13,031 --> 00:34:20,100
block and then we have to splice it out

653
00:34:16,609 --> 00:34:25,940
in just the same way we did in case two

654
00:34:20,379 --> 00:34:27,427
so we splice it out of the the list and

655
00:34:25,094 --> 00:34:29,102
then put it at the beginning of the list

656
00:34:27,859 --> 00:34:32,780
by pointing the root at it and then

657
00:34:30,002 --> 00:34:35,311
updating what used to be the first block

658
00:34:32,078 --> 00:34:37,717
in the list updating its back pointer

659
00:34:35,329 --> 00:34:41,000
it's pre pointer to point to the this

660
00:34:38,419 --> 00:34:42,514
newly coalesced block okay so it's this

661
00:34:41,000 --> 00:34:46,849
is completely symmetric with the case

662
00:34:43,369 --> 00:34:48,421
that we looked at before but now we no

663
00:34:46,849 --> 00:34:49,948
longer have it's a little bit trickier

664
00:34:48,889 --> 00:34:53,540
if we just wanted to leave this block in

665
00:34:50,839 --> 00:34:56,300
the free list we'd have to update all

666
00:34:53,054 --> 00:34:57,373
these pointers to point back to the

667
00:34:56,003 --> 00:35:02,090
beginning of the newly created block

668
00:34:57,859 --> 00:35:06,440
okay so there's so in this case there's

669
00:35:03,017 --> 00:35:07,073
no performance optimization right we're

670
00:35:06,044 --> 00:35:09,071
still updating the same number of

671
00:35:07,073 --> 00:35:11,212
pointers whether we put it in the

672
00:35:09,071 --> 00:35:14,167
beginning of the list or if we if we

673
00:35:11,869 --> 00:35:15,670
splice it or if we leave it there

674
00:35:17,002 --> 00:35:22,054
and now case four is the that's the case

675
00:35:21,099 --> 00:35:26,106
where both the predecessor and successor

676
00:35:22,072 --> 00:35:31,461
blocks are free so we have to apply the

677
00:35:26,799 --> 00:35:35,856
same slicing technique to both the the

678
00:35:32,109 --> 00:35:39,180
predecessor block and we have to we have

679
00:35:36,369 --> 00:35:43,720
to create this new coalesced block and

680
00:35:39,819 --> 00:35:44,844
then we have to splice we have to we

681
00:35:43,072 --> 00:35:50,074
have to sort of splice it out by

682
00:35:45,069 --> 00:35:56,097
updating two different sets of previous

683
00:35:50,074 --> 00:35:59,101
and successor blocks okay so when we

684
00:35:56,349 --> 00:36:01,930
when we're finished with that the this

685
00:36:00,001 --> 00:36:07,003
newly coalesced block now is the first

686
00:36:01,093 --> 00:36:09,012
block in the in the heap the four in the

687
00:36:07,003 --> 00:36:11,047
free list and we spliced it we spliced

688
00:36:09,849 --> 00:36:14,970
it out from these two different parts of

689
00:36:11,047 --> 00:36:14,052
the the free list

690
00:36:17,044 --> 00:36:26,108
okay so any questions about this is this

691
00:36:22,067 --> 00:36:30,068
is where you really it looks it looks

692
00:36:27,008 --> 00:36:34,085
really simple to do but I guarantee you

693
00:36:30,077 --> 00:36:35,156
this will be some of the hardest it's

694
00:36:34,085 --> 00:36:36,182
only like 200 lines of code but some of

695
00:36:36,056 --> 00:36:41,090
the hardest code you'll have to write

696
00:36:37,082 --> 00:36:42,137
because you you're sort of free of the

697
00:36:41,009 --> 00:36:44,063
C's type system you have to do

698
00:36:43,037 --> 00:36:46,115
everything by explicitly casting these

699
00:36:45,044 --> 00:36:52,049
pointers are just in the middle of

700
00:36:47,015 --> 00:36:54,029
arbitrary blocks and so it looks simple

701
00:36:52,049 --> 00:36:55,052
with the diagram but you're going to

702
00:36:54,029 --> 00:37:00,068
have to be really careful when you do

703
00:36:55,052 --> 00:37:03,068
this in fact what I would suggest the

704
00:37:00,068 --> 00:37:05,069
best suggestion I can give you is it is

705
00:37:03,068 --> 00:37:07,142
to start with the implicit list

706
00:37:05,069 --> 00:37:09,104
allocator that we describe in the book

707
00:37:08,042 --> 00:37:11,114
which is too slow to get any credit

708
00:37:10,004 --> 00:37:16,061
terrible allocator but it contains all

709
00:37:12,014 --> 00:37:18,023
the basic ideas and then write function

710
00:37:16,061 --> 00:37:19,157
write a function called insert block and

711
00:37:19,004 --> 00:37:23,081
write another function called remove

712
00:37:20,057 --> 00:37:25,121
block that inserts a block into the free

713
00:37:23,081 --> 00:37:28,130
list and removes a block from the free

714
00:37:26,021 --> 00:37:31,064
list respectively and if you if you

715
00:37:29,003 --> 00:37:32,078
write if you abstract it like that if

716
00:37:31,064 --> 00:37:35,105
you use that kind of abstraction it's

717
00:37:33,005 --> 00:37:37,094
pretty simple to to convert the implicit

718
00:37:36,005 --> 00:37:42,005
list allocator to an explicit list

719
00:37:37,094 --> 00:37:44,102
allocator okay it'll still be too slow

720
00:37:42,005 --> 00:37:50,006
to get so then that will go from like an

721
00:37:45,002 --> 00:37:52,049
F allocator to a b- allocator and then

722
00:37:50,015 --> 00:37:54,074
to really make a good allocator like an

723
00:37:52,049 --> 00:37:58,066
a allocator you need to use sugar is

724
00:37:54,074 --> 00:37:57,166
lists which we'll look at in a second

725
00:37:59,004 --> 00:38:04,039
okay so the explicit list now the the

726
00:38:02,029 --> 00:38:06,078
allocation time is linear in the number

727
00:38:04,039 --> 00:38:10,117
of free blocks instead of the total size

728
00:38:06,339 --> 00:38:12,417
of the instead of the total size of the

729
00:38:11,017 --> 00:38:14,050
heap so it's this is much faster than

730
00:38:13,119 --> 00:38:17,470
that when you have a lot of allocated

731
00:38:14,005 --> 00:38:19,021
blocks it's a little more complicated

732
00:38:17,047 --> 00:38:23,130
because of all the splicing business and

733
00:38:19,066 --> 00:38:26,149
and you do need some extra space in your

734
00:38:24,003 --> 00:38:28,102
for these pointers which increases the

735
00:38:27,049 --> 00:38:35,928
minimum block size and creates

736
00:38:29,029 --> 00:38:38,077
additional overhead now the link list

737
00:38:36,369 --> 00:38:41,470
the explicit list allocators aren't

738
00:38:38,077 --> 00:38:43,080
really sufficient enough to be used for

739
00:38:41,047 --> 00:38:47,089
sort of general purpose real-life

740
00:38:43,008 --> 00:38:49,017
allocator but they are useful in as part

741
00:38:47,089 --> 00:38:51,166
of a segregated list allocator so you

742
00:38:49,809 --> 00:38:54,780
can have you can have multiple free

743
00:38:52,066 --> 00:38:56,164
lists each of which is an explicit list

744
00:38:54,078 --> 00:39:00,142
and it's fine for that for that

745
00:38:57,064 --> 00:39:03,076
application alright so let's look at our

746
00:39:01,042 --> 00:39:06,981
third method which is to create call a

747
00:39:03,076 --> 00:39:08,865
segregated free list which is to have

748
00:39:07,359 --> 00:39:14,700
multiple free lists with different size

749
00:39:09,549 --> 00:39:19,557
classes so the the idea is that each

750
00:39:14,007 --> 00:39:22,039
each class of sizes block sizes has its

751
00:39:20,349 --> 00:39:24,700
own free list and that that class can be

752
00:39:23,002 --> 00:39:27,531
singleton you know maybe a one

753
00:39:24,007 --> 00:39:29,053
particular size or it can be a range of

754
00:39:27,549 --> 00:39:32,740
sizes so you might you might have a

755
00:39:30,016 --> 00:39:35,715
number of different you know if your if

756
00:39:32,074 --> 00:39:36,169
your if your workload consists of a lot

757
00:39:35,859 --> 00:39:38,980
of these small blocks and you know that

758
00:39:37,069 --> 00:39:41,104
there's going to be a lot of requests

759
00:39:38,098 --> 00:39:44,107
for blocks of 1 through 4 you can have

760
00:39:42,004 --> 00:39:48,273
different free lists for those small for

761
00:39:45,088 --> 00:39:49,144
those small block sizes and then after

762
00:39:48,309 --> 00:39:52,720
that you can go and just do ranges of

763
00:39:50,044 --> 00:39:55,066
power of 2 so that's a that's a common

764
00:39:52,072 --> 00:39:57,201
technique so here we have a size class

765
00:39:55,066 --> 00:40:02,265
that covers blocks from size 5 to 8 and

766
00:39:57,849 --> 00:40:05,460
then another size class that covers

767
00:40:02,859 --> 00:40:05,460
everything else

768
00:40:06,309 --> 00:40:11,510
so the idea with the seg list allocators

769
00:40:09,023 --> 00:40:14,122
that given a given an array of these

770
00:40:11,051 --> 00:40:16,600
free lists one each one for for some

771
00:40:14,329 --> 00:40:20,450
size class if we want to allocate a

772
00:40:17,059 --> 00:40:22,138
block of size n then we we go to the

773
00:40:20,045 --> 00:40:24,874
appropriate free list right there's only

774
00:40:22,849 --> 00:40:28,873
there's always going to be one free list

775
00:40:25,279 --> 00:40:30,358
for any any end and then we search that

776
00:40:29,089 --> 00:40:34,138
list just like we did before

777
00:40:31,069 --> 00:40:40,010
for some size if a block size M greater

778
00:40:34,579 --> 00:40:43,880
than n and then if we find it then we

779
00:40:40,001 --> 00:40:46,030
place we place the new block we place

780
00:40:43,088 --> 00:40:48,547
the block in that in the block that we

781
00:40:46,039 --> 00:40:51,020
found we split it and we take this the

782
00:40:49,339 --> 00:40:52,435
split block and we put it into the

783
00:40:51,002 --> 00:40:55,073
appropriate size class so that the block

784
00:40:53,299 --> 00:40:57,325
that we split off may or may not may or

785
00:40:55,073 --> 00:40:58,166
may not belong to the current size class

786
00:40:57,559 --> 00:41:01,567
anymore and so we may have to move it

787
00:40:59,066 --> 00:41:06,095
and insert it into a whatever the

788
00:41:02,359 --> 00:41:08,428
appropriate size class is if there's no

789
00:41:06,095 --> 00:41:10,224
block if we can't find a block then we

790
00:41:09,049 --> 00:41:14,180
have to try the next larger size class

791
00:41:11,079 --> 00:41:16,220
okay so it's possible for a given size

792
00:41:14,018 --> 00:41:21,907
class they're just there might not be a

793
00:41:16,022 --> 00:41:23,911
block that fits so I mean one so we just

794
00:41:22,069 --> 00:41:25,165
have to we go to the next size we try

795
00:41:24,109 --> 00:41:27,208
the next larger class and chances are

796
00:41:26,029 --> 00:41:31,111
we'll find a block that fits there and

797
00:41:28,099 --> 00:41:33,145
if we and you keep doing that until you

798
00:41:31,849 --> 00:41:34,921
eventually if you can't find it you're

799
00:41:33,559 --> 00:41:37,615
eventually looking in the size class

800
00:41:35,569 --> 00:41:40,618
that that that covers all the rest the

801
00:41:38,119 --> 00:41:44,920
last size class and if then you can't

802
00:41:41,059 --> 00:41:48,980
find it then that the allocator has to

803
00:41:44,092 --> 00:41:50,451
allocate more memory with by colleen s

804
00:41:48,098 --> 00:41:50,397
break

805
00:41:52,057 --> 00:41:56,105
okay to free a block you coalesce like

806
00:41:55,061 --> 00:41:59,063
before and then you place it on the

807
00:41:57,005 --> 00:42:01,043
appropriate list so that's that's

808
00:41:59,063 --> 00:42:03,071
straightforward and again you have this

809
00:42:01,043 --> 00:42:05,069
option to try to maintain the listed

810
00:42:03,071 --> 00:42:06,107
address ordered or just do the simple

811
00:42:05,069 --> 00:42:12,094
thing and put it at the beginning of the

812
00:42:07,007 --> 00:42:17,041
list okay so say egg list alligators are

813
00:42:12,094 --> 00:42:19,139
that by far the best type of alligator

814
00:42:17,041 --> 00:42:22,132
because they they offer you improvements

815
00:42:20,039 --> 00:42:26,045
in both performance throughput and

816
00:42:23,032 --> 00:42:28,064
memory utilization so they're faster

817
00:42:26,099 --> 00:42:30,158
they have higher throughputs because the

818
00:42:28,064 --> 00:42:33,137
the individual size classes are are

819
00:42:31,058 --> 00:42:36,110
smaller then than just like the one

820
00:42:34,037 --> 00:42:40,046
giant free list but also you're

821
00:42:37,001 --> 00:42:43,016
searching you know that the list that

822
00:42:41,027 --> 00:42:44,081
you're searching is going to be close to

823
00:42:43,025 --> 00:42:47,069
the size that you're looking for so the

824
00:42:44,081 --> 00:42:49,142
chances of finding something quickly in

825
00:42:47,069 --> 00:42:51,131
that in that particular size class are

826
00:42:50,042 --> 00:42:54,125
higher than they are if you're just

827
00:42:52,031 --> 00:42:56,120
searching on you know a single free list

828
00:42:55,025 --> 00:42:59,039
that holds all different size classes

829
00:42:57,002 --> 00:43:03,074
okay so search is faster so that

830
00:42:59,039 --> 00:43:05,135
increases increases throughput but the

831
00:43:03,092 --> 00:43:08,108
big thing about egg list alligators is

832
00:43:06,035 --> 00:43:11,054
that like we talked about before they

833
00:43:09,008 --> 00:43:14,024
approximate best fit without sacrificing

834
00:43:11,054 --> 00:43:16,097
performance right before if we wanted to

835
00:43:14,024 --> 00:43:18,059
do best fit on a single a free list we

836
00:43:16,097 --> 00:43:20,125
had to search the whole free list and

837
00:43:18,059 --> 00:43:24,083
then choose the block that's it the best

838
00:43:21,025 --> 00:43:27,110
in this case we get we get best fit for

839
00:43:24,083 --> 00:43:34,088
free by by virtue of having these size

840
00:43:28,001 --> 00:43:36,008
classes and so this is you know this is

841
00:43:34,088 --> 00:43:39,097
this is how you can improve your your

842
00:43:36,008 --> 00:43:39,106
memory utilization yes

843
00:43:44,259 --> 00:43:52,315
to me this alligator and more bite or

844
00:43:50,049 --> 00:43:56,930
next oh yeah yeah good question so the

845
00:43:52,819 --> 00:43:59,420
question is is is break constant time it

846
00:43:56,093 --> 00:44:01,097
is but it's very expensive so it's a

847
00:43:59,042 --> 00:44:04,351
Cisco so it has to pass from user space

848
00:44:01,097 --> 00:44:07,366
into the kernel that involves changing

849
00:44:04,729 --> 00:44:12,710
contacts changing stacks so it's this

850
00:44:08,239 --> 00:44:14,630
call generally you can you can count on

851
00:44:12,071 --> 00:44:16,166
assist call being like several hundred

852
00:44:14,063 --> 00:44:20,782
microseconds okay it's a non-trivial

853
00:44:17,066 --> 00:44:22,088
overhead and so in that case you

854
00:44:21,349 --> 00:44:25,910
wouldn't want you you want to amortize

855
00:44:22,088 --> 00:44:28,094
the cost of the of the break by

856
00:44:25,091 --> 00:44:29,114
allocating a somewhat larger chunk but

857
00:44:28,094 --> 00:44:31,393
you have to be careful if you allocate

858
00:44:30,014 --> 00:44:34,019
too large of a chunk then your memory

859
00:44:32,239 --> 00:44:35,420
utilization goes down so it's a

860
00:44:34,019 --> 00:44:40,888
trade-off it's another one of these

861
00:44:35,042 --> 00:44:43,097
space-time trade-offs question so where

862
00:44:41,059 --> 00:44:45,085
do you store this array of free list so

863
00:44:43,097 --> 00:44:49,396
you store it in the beginning of the

864
00:44:45,319 --> 00:44:52,345
heat yeah in fact for your Mallik lab we

865
00:44:50,269 --> 00:44:56,302
require you to do that we don't know and

866
00:44:52,579 --> 00:44:59,690
the reason is we can't bat that array of

867
00:44:56,599 --> 00:45:00,661
sex in some small part depending on how

868
00:44:59,069 --> 00:45:03,388
large that array is it affects your

869
00:45:01,219 --> 00:45:06,880
memory utilization and so it should be

870
00:45:04,009 --> 00:45:06,880
at the beginning of the heat

871
00:45:12,002 --> 00:45:19,035
okay there's a allocators have been

872
00:45:16,005 --> 00:45:24,090
around forever and the the the classic

873
00:45:19,053 --> 00:45:26,094
references Canute's the 1973 text and

874
00:45:24,009 --> 00:45:29,013
there's also this great paper which you

875
00:45:26,094 --> 00:45:32,139
can get from the book's website from

876
00:45:29,094 --> 00:45:34,158
1995 that does a survey of you know

877
00:45:33,039 --> 00:45:36,102
little dozens and dozens of techniques

878
00:45:35,058 --> 00:45:38,127
like we're just scratching the surface

879
00:45:37,002 --> 00:45:42,048
here so if you're really interested in

880
00:45:39,027 --> 00:45:44,031
this stuff that that papers a

881
00:45:42,048 --> 00:45:49,122
fascinating read and it may give you

882
00:45:44,031 --> 00:45:53,085
some ideas for your prelab okay now so

883
00:45:50,022 --> 00:45:55,065
far we're assuming that the application

884
00:45:53,085 --> 00:45:59,091
is responsible for both allocating

885
00:45:55,065 --> 00:46:02,070
storage and freeing storage but there's

886
00:45:59,091 --> 00:46:05,169
there a form of memory managers called

887
00:46:02,007 --> 00:46:09,009
implicit memory managers that do the

888
00:46:06,069 --> 00:46:10,128
freeing for you so so applications

889
00:46:09,072 --> 00:46:12,078
allocate space but they never have to

890
00:46:11,028 --> 00:46:18,063
worry about freeing space the system

891
00:46:13,032 --> 00:46:23,109
does that automatically and so the the

892
00:46:18,063 --> 00:46:25,149
idea is to identify so-called garbage so

893
00:46:24,009 --> 00:46:29,013
areas of memory that can never be

894
00:46:26,049 --> 00:46:31,076
referenced anymore and then free up

895
00:46:29,049 --> 00:46:34,068
those blocks

896
00:46:31,076 --> 00:46:36,090
so what's garbage well here's an example

897
00:46:34,068 --> 00:46:40,068
we have a function foo that now likes

898
00:46:36,009 --> 00:46:43,065
128 bytes it stores the address in this

899
00:46:40,068 --> 00:46:46,074
pointer P and then at some point when it

900
00:46:44,046 --> 00:46:48,084
returns from foo this pointer is lost

901
00:46:47,028 --> 00:46:51,123
forever right because P is a local

902
00:46:48,084 --> 00:46:54,096
variable on the stack so once once this

903
00:46:52,023 --> 00:46:57,075
function returns that the block of

904
00:46:54,096 --> 00:46:59,139
memory pointed to by P is garbage can

905
00:46:57,075 --> 00:47:01,086
never be referenced again because

906
00:47:00,039 --> 00:47:05,055
there's no way there's no way for the

907
00:47:01,086 --> 00:47:07,119
program to get get access to that and so

908
00:47:05,055 --> 00:47:10,080
what an allocator will recognize at some

909
00:47:08,019 --> 00:47:12,096
point that this block of of memory is

910
00:47:10,008 --> 00:47:13,107
garbage and that it will free those

911
00:47:12,096 --> 00:47:17,097
blocks by calling free it's the same

912
00:47:14,079 --> 00:47:21,102
kind of exactly the same free call as

913
00:47:18,006 --> 00:47:23,010
we've discussed but now it's called by

914
00:47:22,002 --> 00:47:26,004
the garbage collector not

915
00:47:23,046 --> 00:47:29,067
the application okay so you see this in

916
00:47:26,004 --> 00:47:31,059
all different kinds of dynamic languages

917
00:47:29,067 --> 00:47:34,122
and there's there's there's also

918
00:47:31,059 --> 00:47:39,144
variants available for C but because of

919
00:47:35,022 --> 00:47:42,024
C's pointer properties that the garbage

920
00:47:40,044 --> 00:47:44,049
collectors for C are conservative in the

921
00:47:42,042 --> 00:47:46,128
sense that there's some blocks won't be

922
00:47:44,049 --> 00:47:49,074
freed there's some garbage blocks that

923
00:47:47,028 --> 00:47:53,079
that won't be free because the allocator

924
00:47:49,074 --> 00:47:55,089
can't determine that that they are

925
00:47:53,079 --> 00:47:58,143
indeed garbage so it has to be careful

926
00:47:55,089 --> 00:48:00,183
when it whenever there's a doubt it it

927
00:47:59,043 --> 00:48:08,046
leaves it doesn't reclaim the the

928
00:48:01,083 --> 00:48:08,169
allocated block so it gets to this

929
00:48:08,046 --> 00:48:13,052
question of like how does the memory

930
00:48:09,069 --> 00:48:16,116
manager know when memory can be free and

931
00:48:13,052 --> 00:48:18,054
you know if we knew if somehow we knew

932
00:48:17,016 --> 00:48:21,060
we could predict all of the future

933
00:48:18,072 --> 00:48:22,149
requests and then if we knew that there

934
00:48:21,006 --> 00:48:25,029
were no future requests access that

935
00:48:23,049 --> 00:48:30,062
block and we could free it okay but we

936
00:48:25,083 --> 00:48:32,091
can't predict that okay so we have to

937
00:48:30,062 --> 00:48:34,140
but if there's no pointers if no

938
00:48:33,063 --> 00:48:36,068
pointers exist to a particular block

939
00:48:35,004 --> 00:48:39,021
then we know that it can't be accessed

940
00:48:37,013 --> 00:48:42,078
okay and so that we can predict right if

941
00:48:39,057 --> 00:48:46,059
there's some way we can sort of a scan

942
00:48:42,078 --> 00:48:48,096
the program identify or scan the memory

943
00:48:46,059 --> 00:48:51,093
identify all the pointers in that memory

944
00:48:48,096 --> 00:48:53,160
and and see which which blocks have

945
00:48:51,093 --> 00:48:55,131
pointed to and it's there if they're not

946
00:48:54,006 --> 00:48:59,055
pointed to by any pointer then then

947
00:48:56,031 --> 00:49:04,038
they're garbage by definition okay so to

948
00:49:00,009 --> 00:49:06,045
do this though it's difficult so first

949
00:49:04,038 --> 00:49:07,044
of all the memory manager has to be able

950
00:49:06,045 --> 00:49:10,083
to distinguish pointers from non

951
00:49:07,098 --> 00:49:10,167
pointers which we can't do and see right

952
00:49:10,083 --> 00:49:13,164
they're just these

953
00:49:11,067 --> 00:49:17,136
they're just these integral values right

954
00:49:14,064 --> 00:49:20,082
we don't know it could be it if we see

955
00:49:18,036 --> 00:49:24,099
this large integral value this large

956
00:49:20,082 --> 00:49:25,164
long eight byte value it could be it

957
00:49:24,099 --> 00:49:27,123
could be pointing to a data structure it

958
00:49:26,064 --> 00:49:33,072
could just be a large integer right we

959
00:49:28,023 --> 00:49:34,116
don't know and then we also all pointers

960
00:49:33,072 --> 00:49:36,901
have to point to the start of a block

961
00:49:35,016 --> 00:49:40,113
which is not true and see either

962
00:49:37,549 --> 00:49:43,140
okay so if we have a pointer and we

963
00:49:41,013 --> 00:49:45,242
identify that at the pointer then we

964
00:49:43,014 --> 00:49:47,019
know that it points it points to some

965
00:49:45,359 --> 00:49:49,140
block if it points inside of a block how

966
00:49:47,064 --> 00:49:50,163
do we how do we find the beginning of

967
00:49:49,014 --> 00:49:53,091
that block you know how do we know how

968
00:49:51,063 --> 00:49:54,146
big that block is so it has to point to

969
00:49:53,091 --> 00:50:00,800
the beginning of the block or the header

970
00:49:55,046 --> 00:50:02,097
tells us the size and the and and and

971
00:50:01,619 --> 00:50:03,713
there can't be a way to hide pointers

972
00:50:02,097 --> 00:50:06,226
the point that the property of being a

973
00:50:04,559 --> 00:50:11,588
pointer has to be some kind of static

974
00:50:07,099 --> 00:50:12,197
saying that doesn't that can't change so

975
00:50:11,849 --> 00:50:14,280
that's sort of the challenges if you're

976
00:50:13,079 --> 00:50:15,630
thinking about how in the world can you

977
00:50:14,028 --> 00:50:17,567
implement a garbage collector so those

978
00:50:15,063 --> 00:50:20,012
are some of the challenges that that

979
00:50:17,819 --> 00:50:23,490
they present and because of that it's

980
00:50:20,579 --> 00:50:26,750
been a history of research and garbage

981
00:50:23,049 --> 00:50:29,088
collectors it is old its ancient and

982
00:50:26,075 --> 00:50:30,171
ongoing it's still it's still ongoing

983
00:50:29,088 --> 00:50:33,089
today particularly in the context of

984
00:50:31,071 --> 00:50:35,180
parallel programs and garbage collecting

985
00:50:33,089 --> 00:50:36,998
programs that are running multiple

986
00:50:35,819 --> 00:50:40,950
threads so there's a whole bunch of

987
00:50:37,799 --> 00:50:43,500
these things that people have looked at

988
00:50:40,095 --> 00:50:45,120
going all the way back to 1960

989
00:50:43,005 --> 00:50:48,021
today we'll look at we'll look at the

990
00:50:46,002 --> 00:50:50,028
simplest what one of the simpler

991
00:50:48,066 --> 00:50:51,995
variants called mark-and-sweep and we

992
00:50:50,046 --> 00:50:53,067
won't we won't discuss the rest but if

993
00:50:52,589 --> 00:50:55,980
you're interested in them there's a

994
00:50:53,067 --> 00:50:59,154
pretty good book that describes that

995
00:50:55,098 --> 00:51:02,237
describes these things all right so how

996
00:51:00,054 --> 00:51:05,091
do we build an allocator so we start by

997
00:51:03,119 --> 00:51:10,163
viewing memory as a directed graph where

998
00:51:05,091 --> 00:51:17,120
each each node in the graph corresponds

999
00:51:10,559 --> 00:51:18,200
to a block okay a block a heap block and

1000
00:51:18,005 --> 00:51:26,052
eaten out an allocated heap block and

1001
00:51:23,066 --> 00:51:29,735
each edge is a pointer that's contained

1002
00:51:26,097 --> 00:51:33,099
somewhere within that block pointer to

1003
00:51:30,329 --> 00:51:36,510
another block and then there's a and

1004
00:51:34,017 --> 00:51:39,024
then there's special nodes called root

1005
00:51:36,051 --> 00:51:40,053
nodes that contain pointers into the

1006
00:51:39,024 --> 00:51:42,117
heap but they're not part of the heap so

1007
00:51:40,071 --> 00:51:44,079
for example pointers that are stored on

1008
00:51:43,017 --> 00:51:48,686
the stack pointers that are stored in

1009
00:51:45,051 --> 00:51:49,077
registers they point to memory locations

1010
00:51:48,839 --> 00:51:54,960
in the heap

1011
00:51:49,077 --> 00:51:56,121
but nothing nothing and but there

1012
00:51:54,096 --> 00:51:58,125
outside of the heat so and we call those

1013
00:51:57,021 --> 00:52:00,069
root notes so nothing points to them or

1014
00:51:59,025 --> 00:52:02,033
at least if something does point to them

1015
00:52:00,069 --> 00:52:04,110
we don't care about what it is okay

1016
00:52:03,005 --> 00:52:08,094
we're only we're only concerned about

1017
00:52:05,001 --> 00:52:12,083
characterizing nodes that correspond to

1018
00:52:08,094 --> 00:52:14,163
memory in the heap so I we say that a

1019
00:52:12,092 --> 00:52:19,140
node or a block is reachable if there's

1020
00:52:15,063 --> 00:52:22,086
some path from a root node from a root

1021
00:52:20,004 --> 00:52:24,057
node to that block so and we've denoted

1022
00:52:22,086 --> 00:52:26,100
those by green so all of these green

1023
00:52:24,093 --> 00:52:27,159
blocks in the heap are reachable because

1024
00:52:27,000 --> 00:52:31,008
you can start at a root node and just

1025
00:52:28,059 --> 00:52:33,155
follow some some sequence of pointers to

1026
00:52:31,008 --> 00:52:39,039
get to that node okay

1027
00:52:34,055 --> 00:52:41,067
notes that aren't reachable are called

1028
00:52:39,039 --> 00:52:43,101
our garbage because there's no there's

1029
00:52:41,067 --> 00:52:45,153
no way to get to them from the root

1030
00:52:44,001 --> 00:52:48,009
nodes okay so there's no node inside the

1031
00:52:46,053 --> 00:52:51,060
heat that points to them and there's no

1032
00:52:48,081 --> 00:52:52,125
node there's no root node that points to

1033
00:52:51,006 --> 00:52:54,084
them so basically there's just no path

1034
00:52:53,025 --> 00:52:58,074
from a root node that'll get you to one

1035
00:52:55,038 --> 00:53:02,115
of these non reachable or garbage nodes

1036
00:52:58,074 --> 00:53:03,081
and since they're non reachable the

1037
00:53:03,015 --> 00:53:06,054
application will never be able to

1038
00:53:04,044 --> 00:53:08,091
reference them in the future so we can

1039
00:53:06,054 --> 00:53:11,150
predict with certainty that that those

1040
00:53:08,091 --> 00:53:14,103
are garbage and they can be freed okay

1041
00:53:12,005 --> 00:53:17,054
so basically after we free these then

1042
00:53:15,003 --> 00:53:17,099
they're removed from the graph

1043
00:53:22,051 --> 00:53:28,097
so now we can we can build a simple

1044
00:53:27,079 --> 00:53:30,920
garbage collector on top of the existing

1045
00:53:28,097 --> 00:53:31,966
malloc and free package right so you

1046
00:53:30,092 --> 00:53:38,120
implement now I can free just like

1047
00:53:32,839 --> 00:53:42,230
before and then you if the program calls

1048
00:53:39,002 --> 00:53:43,891
malloc just like before and you just you

1049
00:53:42,023 --> 00:53:46,025
do malloc exactly the same way until you

1050
00:53:44,089 --> 00:53:47,188
run out of space by whatever definition

1051
00:53:46,043 --> 00:53:49,139
you want to use of running out of space

1052
00:53:48,079 --> 00:53:52,156
maybe you have some kind of maximum each

1053
00:53:50,039 --> 00:53:54,047
size you're willing to use or at some

1054
00:53:52,849 --> 00:53:58,926
point the OS will just stop giving you

1055
00:53:54,047 --> 00:53:59,196
virtual memory when you run out of space

1056
00:54:00,028 --> 00:54:06,104
you you add an extra mark bit into the

1057
00:54:05,021 --> 00:54:08,044
header of each block so this could be

1058
00:54:07,004 --> 00:54:11,006
you know we have like three or four

1059
00:54:08,044 --> 00:54:12,973
spare bits that we can use in the header

1060
00:54:11,024 --> 00:54:16,052
so we can denote one of those that's the

1061
00:54:13,369 --> 00:54:21,170
mark bit and then we are garbage

1062
00:54:16,052 --> 00:54:23,113
collection our garbage collection phase

1063
00:54:21,017 --> 00:54:26,096
when we run out of space consists of two

1064
00:54:24,013 --> 00:54:28,702
two different sub phases one is the mark

1065
00:54:26,096 --> 00:54:31,130
phase which starts at all the roots and

1066
00:54:28,819 --> 00:54:35,660
then and it just traverses this from the

1067
00:54:32,003 --> 00:54:37,042
roots it traverses the set of of nodes

1068
00:54:35,066 --> 00:54:38,114
that are reachable from the root and it

1069
00:54:37,339 --> 00:54:43,460
sets the mark that in each each one of

1070
00:54:39,014 --> 00:54:46,453
those nodes ok and then once after you

1071
00:54:43,046 --> 00:54:47,144
finish marking all of the all of the

1072
00:54:46,579 --> 00:54:50,270
reachable blocks then you sweep through

1073
00:54:48,044 --> 00:54:53,433
the entire heap starting at the very

1074
00:54:50,027 --> 00:54:56,054
beginning of the heap and you look for

1075
00:54:53,829 --> 00:54:58,831
you look for all allocated blocks that

1076
00:54:56,054 --> 00:54:59,117
aren't marked okay because they're not

1077
00:54:58,849 --> 00:55:01,875
marked they're not reachable in their

1078
00:55:00,017 --> 00:55:06,080
garbage

1079
00:55:02,109 --> 00:55:10,490
sofirst so you do this so you sort of do

1080
00:55:06,008 --> 00:55:11,033
- you do a search from the from the

1081
00:55:10,049 --> 00:55:14,065
roots and then you do a sweep of the

1082
00:55:12,005 --> 00:55:14,011
entire heat

1083
00:55:17,007 --> 00:55:24,064
so let's say before the for mark we have

1084
00:55:20,014 --> 00:55:26,017
a before the marks phase we have a heap

1085
00:55:24,064 --> 00:55:29,086
that looks like this we have a single

1086
00:55:26,017 --> 00:55:30,022
root that points to this block and what

1087
00:55:29,086 --> 00:55:32,155
we're going to do here we're always

1088
00:55:30,067 --> 00:55:35,089
going to point to the payload right of

1089
00:55:33,055 --> 00:55:38,110
the of the block just a convention that

1090
00:55:35,089 --> 00:55:40,105
we use so we're pointing to the

1091
00:55:39,001 --> 00:55:44,047
beginning of the block because we know

1092
00:55:41,005 --> 00:55:49,039
that it's we know that the the header is

1093
00:55:44,056 --> 00:55:52,141
one one word behind it and so let's say

1094
00:55:49,039 --> 00:55:54,115
and in this case the the edges denote

1095
00:55:53,041 --> 00:55:56,092
pointers that are contained in the block

1096
00:55:55,015 --> 00:55:58,051
so they're not the previous and next

1097
00:55:56,092 --> 00:55:59,119
pointers that we were maintaining these

1098
00:55:58,051 --> 00:56:04,084
are just pointers that the application

1099
00:56:00,019 --> 00:56:06,048
has put into those blocks so we have so

1100
00:56:04,084 --> 00:56:09,151
here we have the root pointing to this

1101
00:56:06,048 --> 00:56:11,122
central block and then there's and and

1102
00:56:10,051 --> 00:56:13,102
there's a pointer that points to this

1103
00:56:12,022 --> 00:56:16,045
block and there's another pointer that

1104
00:56:14,002 --> 00:56:18,004
points to this block and and there's a

1105
00:56:16,045 --> 00:56:21,097
pointer in this block that points to

1106
00:56:18,004 --> 00:56:25,027
this block so after we do the mark and

1107
00:56:21,097 --> 00:56:27,246
we search this we search these blocks

1108
00:56:25,027 --> 00:56:30,031
and all of the reachable blocks have the

1109
00:56:28,119 --> 00:56:33,400
mark bit set which is denoted by tink

1110
00:56:30,031 --> 00:56:35,044
and so then you see a net and then the

1111
00:56:33,004 --> 00:56:39,007
the blocks that aren't aren't marked

1112
00:56:35,044 --> 00:56:41,046
then we can free and return to the free

1113
00:56:39,043 --> 00:56:41,046
list

1114
00:56:42,072 --> 00:56:46,089
okay so let's look at the assumptions

1115
00:56:44,849 --> 00:56:49,650
for a simple implementation just to make

1116
00:56:46,089 --> 00:56:51,150
make sure this is clear so the

1117
00:56:49,065 --> 00:56:53,139
application calls new to get a pointer

1118
00:56:52,005 --> 00:56:58,071
to a block with with all those values

1119
00:56:54,039 --> 00:57:02,048
cleared it calls read D I to read

1120
00:56:59,016 --> 00:57:07,023
location I of Block B and it uses write

1121
00:57:03,029 --> 00:57:09,608
div to write a value V into location I

1122
00:57:07,023 --> 00:57:11,118
of Block B then each block will have a

1123
00:57:09,869 --> 00:57:17,640
header word which will address as B of

1124
00:57:12,018 --> 00:57:21,102
minus 1 and then the garbage collector

1125
00:57:17,064 --> 00:57:24,147
has it has functions that it uses to

1126
00:57:22,002 --> 00:57:27,581
identify whether a pointer whether its

1127
00:57:25,047 --> 00:57:28,646
input parameter is indeed a pointer ok

1128
00:57:27,599 --> 00:57:31,800
so there's some way to distinguish a

1129
00:57:29,069 --> 00:57:34,740
pointer from an on pointer and it can

1130
00:57:31,008 --> 00:57:35,052
get the length of some block not

1131
00:57:34,074 --> 00:57:41,129
including the header and it can get a

1132
00:57:36,024 --> 00:57:45,066
set of all of the routes so given those

1133
00:57:42,029 --> 00:57:50,588
given those assumptions we our

1134
00:57:45,066 --> 00:57:53,139
pseudocode for the mark step it takes so

1135
00:57:50,849 --> 00:57:58,920
this initially is a is a pointer a route

1136
00:57:54,039 --> 00:58:01,068
pointer okay and then we check as our

1137
00:57:58,092 --> 00:58:03,011
terminating condition we check to see if

1138
00:58:01,068 --> 00:58:07,149
that that input is indeed a pointer and

1139
00:58:03,839 --> 00:58:10,865
if so we return okay and then then we do

1140
00:58:08,049 --> 00:58:15,123
a depth-first traversal of the of the

1141
00:58:11,099 --> 00:58:17,880
graph so if and this so we're doing a

1142
00:58:16,023 --> 00:58:18,902
depth-first traversal of the graph and

1143
00:58:17,088 --> 00:58:20,297
this is pointer is sort of our

1144
00:58:19,109 --> 00:58:24,660
terminating condition for that that

1145
00:58:21,089 --> 00:58:26,460
depth-first traversal then we check the

1146
00:58:24,066 --> 00:58:27,275
mark bit and if it's set then that's

1147
00:58:26,046 --> 00:58:30,099
another terminating condition there's no

1148
00:58:27,869 --> 00:58:34,892
there's no reason to search once we find

1149
00:58:30,099 --> 00:58:35,978
a marked marked node we know that all of

1150
00:58:35,099 --> 00:58:39,720
everything reachable from that node is

1151
00:58:36,869 --> 00:58:42,930
is marked so we we can terminate our

1152
00:58:39,072 --> 00:58:44,441
return and just stop the search if it's

1153
00:58:42,093 --> 00:58:49,252
not set then we set the mark bit and

1154
00:58:45,089 --> 00:58:50,089
then we look at each word in the block

1155
00:58:50,082 --> 00:58:54,135
and we recursively call mark on each one

1156
00:58:53,043 --> 00:58:56,112
of those words now each one of those

1157
00:58:55,035 --> 00:58:59,082
words may or may not be a pointer right

1158
00:58:57,012 --> 00:59:03,054
so if it's not a pointer then mark will

1159
00:58:59,082 --> 00:59:04,145
just return instantly immediately if it

1160
00:59:03,054 --> 00:59:08,118
is a pointer then it will continue the

1161
00:59:05,045 --> 00:59:10,068
recursive depth first search okay so

1162
00:59:09,018 --> 00:59:13,065
does that make sense it's just a

1163
00:59:10,068 --> 00:59:18,071
familiar the familiar depth-first graph

1164
00:59:13,065 --> 00:59:22,113
traversal of it that we all know about

1165
00:59:18,071 --> 00:59:24,120
okay and then the sweep sweep take a

1166
00:59:23,013 --> 00:59:27,021
pointer to the beginning of the heat

1167
00:59:25,002 --> 00:59:29,079
this first take the pointer to the first

1168
00:59:27,021 --> 00:59:33,096
block in the heat and then some pointer

1169
00:59:29,097 --> 00:59:35,190
to the end of the heat and then in a

1170
00:59:33,096 --> 00:59:39,150
while loop then it scans the heap each

1171
00:59:36,009 --> 00:59:41,093
block if the mark bit is set it clears

1172
00:59:40,005 --> 00:59:42,029
it

1173
00:59:44,077 --> 00:59:51,093
if it if it's allocated it frees it

1174
00:59:49,051 --> 00:59:51,093
right

1175
00:59:53,007 --> 00:59:57,012
and then it updates and then it gets the

1176
00:59:55,023 --> 01:00:05,067
address of the the next block and then

1177
00:59:57,057 --> 01:00:06,150
just continues until the end okay so how

1178
01:00:05,067 --> 01:00:08,070
do we do such a thing in C right because

1179
01:00:07,005 --> 01:00:10,080
all of these assumptions I've made don't

1180
01:00:08,097 --> 01:00:12,129
hold and C you can't tell a pointer from

1181
01:00:11,025 --> 01:00:19,059
an on pointer pointers can point

1182
01:00:13,029 --> 01:00:27,077
anywhere so what you could do so the big

1183
01:00:19,059 --> 01:00:29,118
issue is that if we get some value we it

1184
01:00:27,077 --> 01:00:33,083
even if it is a pointer it could point

1185
01:00:30,018 --> 01:00:33,083
right into the middle of the block so

1186
01:00:34,016 --> 01:00:38,091
given that so first of all we don't know

1187
01:00:37,023 --> 01:00:40,116
if that value really is a pointer it

1188
01:00:38,091 --> 01:00:41,184
could just be a big integer but it also

1189
01:00:41,016 --> 01:00:46,077
could be a pointer that's pointing into

1190
01:00:42,084 --> 01:00:48,126
some data structure so if it is a

1191
01:00:46,077 --> 01:00:52,080
pointer how do we how do we find the

1192
01:00:49,026 --> 01:00:55,077
beginning of the block so what we could

1193
01:00:52,008 --> 01:00:57,102
do is just assume that every value is a

1194
01:00:55,077 --> 01:00:59,154
pointer and then we maintain a balance

1195
01:00:58,074 --> 01:01:01,173
tree to keep track of all the allocated

1196
01:01:00,054 --> 01:01:04,128
blocks and so whenever we encounter a

1197
01:01:02,073 --> 01:01:07,155
particular value we would search that

1198
01:01:05,028 --> 01:01:11,034
binary tree to see if it assuming it is

1199
01:01:08,055 --> 01:01:13,077
a pointer is it falls within the the

1200
01:01:11,088 --> 01:01:16,095
beginning and end of some allocated

1201
01:01:13,077 --> 01:01:18,165
block okay if if that condition is true

1202
01:01:17,058 --> 01:01:20,142
then we assume that it's pointing that

1203
01:01:19,065 --> 01:01:23,139
that's a pointer to an allocated block

1204
01:01:21,042 --> 01:01:25,137
and we assume that that block is

1205
01:01:24,039 --> 01:01:27,108
reachable now the reason it's

1206
01:01:26,037 --> 01:01:28,125
conservative is because it really may

1207
01:01:28,008 --> 01:01:31,011
not be a pointer it might be this

1208
01:01:29,025 --> 01:01:33,072
integer and we'll we'll assume it's a

1209
01:01:31,038 --> 01:01:35,136
pointer and assume that the block that

1210
01:01:33,072 --> 01:01:38,076
it purportedly points to is allocated

1211
01:01:36,036 --> 01:01:40,113
but it may in fact be not be a pointer

1212
01:01:39,012 --> 01:01:43,044
and the block that it points to is

1213
01:01:41,013 --> 01:01:46,089
garbage right so what with this with

1214
01:01:43,044 --> 01:01:50,142
this scheme we would leave some some non

1215
01:01:46,089 --> 01:01:52,095
non reachable blocks we will indicate

1216
01:01:51,042 --> 01:01:55,130
that some non reachable blocks are are

1217
01:01:53,049 --> 01:01:55,130
really reachable

1218
01:01:56,064 --> 01:02:02,943
okay so so once now that we've got this

1219
01:02:01,359 --> 01:02:07,450
great tool to dynamically allocate

1220
01:02:03,519 --> 01:02:08,616
memory we can use it in our programs and

1221
01:02:07,045 --> 01:02:10,884
shoot ourselves in the foot in all

1222
01:02:09,489 --> 01:02:13,494
different kinds of ways okay so I'm

1223
01:02:11,289 --> 01:02:16,344
going to I'm going to try to help help

1224
01:02:13,989 --> 01:02:18,910
you out here by identifying some of the

1225
01:02:16,839 --> 01:02:21,390
perils and pitfalls that that we can run

1226
01:02:18,091 --> 01:02:25,113
into it with with memory related

1227
01:02:21,039 --> 01:02:29,065
operations or operations on memory and

1228
01:02:26,013 --> 01:02:34,096
opera errors errors involving memory are

1229
01:02:29,065 --> 01:02:36,984
the worst the worst kinds of bugs to try

1230
01:02:34,096 --> 01:02:38,745
to find out and the reason is that

1231
01:02:37,569 --> 01:02:42,190
they're distant in both space and time

1232
01:02:39,609 --> 01:02:43,650
so let's say you write to the wrong

1233
01:02:42,019 --> 01:02:47,598
memory location and corrupt some data

1234
01:02:44,019 --> 01:02:51,075
structures the right doesn't elicit any

1235
01:02:47,769 --> 01:02:53,769
error you only find out about that illy

1236
01:02:51,579 --> 01:02:55,450
that erroneous right when you try to

1237
01:02:53,769 --> 01:02:56,790
reference that data structure or that

1238
01:02:55,045 --> 01:02:58,914
particular part of the data structure

1239
01:02:56,979 --> 01:03:00,984
which may be in a part of the code

1240
01:02:59,319 --> 01:03:04,341
that's way far away from the right that

1241
01:03:01,479 --> 01:03:06,460
caused the problem both in space you

1242
01:03:04,539 --> 01:03:07,539
know in distance you know lines of code

1243
01:03:06,046 --> 01:03:08,445
it could be a completely different

1244
01:03:07,539 --> 01:03:11,541
function and a completely different

1245
01:03:08,859 --> 01:03:12,945
module but also in time it may not you

1246
01:03:11,739 --> 01:03:16,746
know you may do the right and then eons

1247
01:03:13,719 --> 01:03:18,160
later other some read and it fails right

1248
01:03:16,809 --> 01:03:19,905
so this is a fundamental thing that

1249
01:03:18,016 --> 01:03:25,113
makes memory related bugs just so nasty

1250
01:03:20,769 --> 01:03:30,700
and another big thing another thing that

1251
01:03:26,013 --> 01:03:32,068
makes them hard to deal with is people's

1252
01:03:30,007 --> 01:03:33,103
misunderstanding and misuse of pointers

1253
01:03:32,068 --> 01:03:37,144
right so usually an erroneous right is

1254
01:03:34,066 --> 01:03:40,069
some is some either a misunderstanding

1255
01:03:38,044 --> 01:03:42,118
of pointers or an improperly initialized

1256
01:03:40,096 --> 01:03:47,715
pointer so it all boils down to these

1257
01:03:43,018 --> 01:03:52,557
pointers okay and so I'm going to show

1258
01:03:48,579 --> 01:03:55,650
you how to understand pointers okay for

1259
01:03:52,719 --> 01:03:55,650
the first time in your lives

1260
01:03:55,069 --> 01:04:01,075
I don't know about you but when I

1261
01:03:57,064 --> 01:04:03,115
learned C I learned about pointers I

1262
01:04:02,029 --> 01:04:06,031
just knew about what a few different

1263
01:04:04,015 --> 01:04:08,098
types of pointers were by and I did it

1264
01:04:06,031 --> 01:04:12,064
by pattern matching so I knew that int

1265
01:04:08,098 --> 01:04:14,149
star P was a pointer to an int I knew

1266
01:04:12,064 --> 01:04:18,073
that int star star P was was an array

1267
01:04:15,049 --> 01:04:21,073
I knew that int star key Open bracket

1268
01:04:19,054 --> 01:04:23,146
close bracket was also an array just a

1269
01:04:21,073 --> 01:04:27,073
different way to express that a race I

1270
01:04:24,046 --> 01:04:29,065
had a small handful of pointers types

1271
01:04:27,073 --> 01:04:31,081
that I could deal with but I had no

1272
01:04:29,065 --> 01:04:32,754
underlying understanding of what that

1273
01:04:31,081 --> 01:04:35,100
meant or anything was just pure pattern

1274
01:04:33,339 --> 01:04:37,340
matching and I'll bet you that's the way

1275
01:04:35,829 --> 01:04:39,190
you do it too

1276
01:04:37,349 --> 01:04:40,397
all right but that's all going to change

1277
01:04:39,019 --> 01:04:44,448
today

1278
01:04:40,829 --> 01:04:47,140
all right so in order to really

1279
01:04:44,619 --> 01:04:50,290
understand pointers you need to

1280
01:04:47,014 --> 01:04:53,089
understand the precedence of various

1281
01:04:50,029 --> 01:04:55,090
operators in C because the pointer types

1282
01:04:53,089 --> 01:04:58,171
are declared using these operators and

1283
01:04:55,009 --> 01:05:02,448
so my copy of K and R it has a dog-eared

1284
01:04:59,071 --> 01:05:05,113
at page 53 this table comes from page 53

1285
01:05:03,339 --> 01:05:09,630
of knr and you should have a paper clip

1286
01:05:06,013 --> 01:05:13,090
or have that folded over for reference

1287
01:05:09,063 --> 01:05:15,139
now the thing to notice is that function

1288
01:05:13,009 --> 01:05:17,928
and array and then and these struct

1289
01:05:16,039 --> 01:05:22,095
these various struct operators have the

1290
01:05:18,819 --> 01:05:26,230
highest priority highest precedence and

1291
01:05:22,095 --> 01:05:27,264
that and then that's followed by unary

1292
01:05:26,023 --> 01:05:30,094
operators so the star this is the

1293
01:05:28,119 --> 01:05:34,690
dereference operator and then the the

1294
01:05:30,094 --> 01:05:38,122
address of operator these there they

1295
01:05:34,069 --> 01:05:41,958
fall right below the highest the highest

1296
01:05:39,022 --> 01:05:44,077
precedence operators and then the binary

1297
01:05:42,579 --> 01:05:47,579
versions of operators in order to use in

1298
01:05:44,077 --> 01:05:50,098
arithmetic operations are below those

1299
01:05:47,579 --> 01:05:56,320
okay so just remember that function and

1300
01:05:50,098 --> 01:05:59,182
array is higher than star okay

1301
01:05:56,032 --> 01:06:02,116
that to do the dereference now the great

1302
01:06:00,082 --> 01:06:04,168
thing about pointers although they

1303
01:06:03,016 --> 01:06:08,110
always seem really complicated is that

1304
01:06:05,068 --> 01:06:11,116
there's there's an algorithm for it for

1305
01:06:09,001 --> 01:06:13,096
there's an algorithm for constructing an

1306
01:06:12,016 --> 01:06:17,028
English sentence that explains exactly

1307
01:06:14,005 --> 01:06:21,052
what what that pointer what that

1308
01:06:17,028 --> 01:06:22,126
definition of the pointer means okay and

1309
01:06:21,052 --> 01:06:27,061
if you're interested it's in the KN are

1310
01:06:23,026 --> 01:06:31,033
in Section 5.1 - but I'll I'll explain

1311
01:06:27,061 --> 01:06:32,062
it to you now now I don't know I don't

1312
01:06:31,033 --> 01:06:34,108
know how much in this class you're going

1313
01:06:32,062 --> 01:06:35,140
to remember okay but I guarantee you

1314
01:06:35,008 --> 01:06:40,062
you're going to remember this as the day

1315
01:06:36,004 --> 01:06:40,026
you finally understood pointers okay so

1316
01:06:42,009 --> 01:06:47,098
all right so here's how it works you

1317
01:06:44,004 --> 01:06:50,098
always start it the this is a definition

1318
01:06:47,098 --> 01:06:55,107
of a pointer some kind you always start

1319
01:06:51,034 --> 01:06:55,107
with the variable name

1320
01:07:00,002 --> 01:07:04,065
and then you use your precedence then

1321
01:07:02,094 --> 01:07:05,172
you look for operators on either side of

1322
01:07:04,065 --> 01:07:08,150
that varial variable name and you choose

1323
01:07:06,072 --> 01:07:12,087
the one that has the highest precedence

1324
01:07:09,005 --> 01:07:17,052
okay so we start with the variable so we

1325
01:07:12,087 --> 01:07:18,090
say t is a then we look to the left and

1326
01:07:17,097 --> 01:07:20,103
the right there's nothing to the right

1327
01:07:19,017 --> 01:07:25,050
but there's a there's a pointer symbol

1328
01:07:21,003 --> 01:07:27,039
to the left so we say t is a pointer and

1329
01:07:25,005 --> 01:07:28,089
there's nothing more and then we always

1330
01:07:27,039 --> 01:07:34,121
end up with the the type of thing that

1331
01:07:29,034 --> 01:07:34,121
it points that so P is a pointer to int

1332
01:07:43,003 --> 01:07:50,092
like Sookie is P as a pointer to some to

1333
01:07:48,091 --> 01:07:52,147
some integer in memory okay so we all

1334
01:07:50,092 --> 01:07:55,120
know that one that's pretty easy okay

1335
01:07:53,047 --> 01:07:57,054
what about the next one you've probably

1336
01:07:56,002 --> 01:08:01,006
seen something like this

1337
01:07:58,017 --> 01:08:05,029
some programs declare our D using this

1338
01:08:01,024 --> 01:08:11,026
notation and so this you can have an

1339
01:08:05,029 --> 01:08:15,037
optional size or not so so we always

1340
01:08:11,026 --> 01:08:16,090
start out we say T is a well now in this

1341
01:08:15,037 --> 01:08:17,044
case there's operators to the left and

1342
01:08:16,009 --> 01:08:18,028
the right

1343
01:08:17,044 --> 01:08:21,121
remember the array operator has higher

1344
01:08:19,009 --> 01:08:23,107
precedence than that the the

1345
01:08:22,021 --> 01:08:29,080
dereferencing operator the pointer

1346
01:08:24,007 --> 01:08:35,092
operators so we say so T is an array 13

1347
01:08:29,008 --> 01:08:38,014
array of size 13 of so there's nothing

1348
01:08:35,092 --> 01:08:44,169
more so we go to the left of pointers so

1349
01:08:39,004 --> 01:08:45,033
T is an array 13 of pointers to ends

1350
01:08:49,929 --> 01:09:04,933
so t is an array of 13 pointers each of

1351
01:09:00,044 --> 01:09:06,092
which points to an end right in this

1352
01:09:05,329 --> 01:09:12,020
case P is just that the name of the

1353
01:09:06,092 --> 01:09:12,188
array so bytes by default P P is a is

1354
01:09:12,002 --> 01:09:16,261
equivalent is the address of the array

1355
01:09:13,088 --> 01:09:17,737
when you reference an array name you're

1356
01:09:16,279 --> 01:09:20,302
you're you're addressing your active

1357
01:09:18,529 --> 01:09:26,587
dressing the address of the first

1358
01:09:20,509 --> 01:09:28,543
element okay how about the next one here

1359
01:09:27,109 --> 01:09:31,114
we're being if we put parentheses around

1360
01:09:28,849 --> 01:09:33,770
things then we can be explicit okay and

1361
01:09:31,159 --> 01:09:36,178
this is a good practice so here we're

1362
01:09:33,077 --> 01:09:39,646
saying T and we have to look at this one

1363
01:09:36,349 --> 01:09:43,040
first because of the parenthesis so T is

1364
01:09:40,339 --> 01:09:44,404
an array thirteen of pointers to ends so

1365
01:09:43,004 --> 01:09:46,143
that's the same thing and here we're

1366
01:09:44,989 --> 01:09:51,064
just being more explicit

1367
01:09:46,179 --> 01:09:56,233
now what about star star T so P is a

1368
01:09:51,739 --> 01:10:00,070
pointer to a pointer to an int okay so

1369
01:09:56,719 --> 01:10:00,070
this is a different type of array

1370
01:10:01,036 --> 01:10:15,097
so P is a pointer to a pointer to an end

1371
01:10:09,081 --> 01:10:20,098
okay and and typically so this is

1372
01:10:15,097 --> 01:10:22,146
another way to do a raise so the same

1373
01:10:20,098 --> 01:10:27,103
way the char star points to a string

1374
01:10:23,046 --> 01:10:30,058
this this can point it points to it

1375
01:10:28,048 --> 01:10:32,095
points to up a pointer but then you can

1376
01:10:30,058 --> 01:10:40,087
index on that each one of those ven

1377
01:10:32,095 --> 01:10:45,127
points corresponds to a pointer whoops

1378
01:10:40,087 --> 01:10:46,093
okay here's another one now P because

1379
01:10:46,027 --> 01:10:50,086
and because of the parentheses we have

1380
01:10:47,047 --> 01:10:56,140
to go left so P is a pointer to an array

1381
01:10:50,086 --> 01:11:02,172
13 of Imps okay so P isn't a pointer to

1382
01:10:57,004 --> 01:11:03,036
an array of 13 inch

1383
01:11:10,062 --> 01:11:19,090
all right now what about this one

1384
01:11:13,041 --> 01:11:23,047
f is a function or is it a function or a

1385
01:11:19,009 --> 01:11:27,012
pointer F is a function right because of

1386
01:11:24,001 --> 01:11:32,095
the precedence so f is a F is a function

1387
01:11:27,093 --> 01:11:38,179
returning pointer to int okay so if we

1388
01:11:32,095 --> 01:11:44,139
go if we go P equal F then that returns

1389
01:11:39,079 --> 01:11:44,085
that initialized P to point to some int

1390
01:11:48,076 --> 01:11:55,153
all right and I'm going to do this one

1391
01:11:53,006 --> 01:11:58,097
let's jump down in the interest of time

1392
01:11:56,053 --> 01:12:00,136
totally ridiculous case just so you can

1393
01:11:58,097 --> 01:12:06,143
see that this algorithm works

1394
01:12:01,036 --> 01:12:15,044
all right so X is an array of pointers

1395
01:12:07,043 --> 01:12:19,097
to functions returning pointers to an

1396
01:12:16,016 --> 01:12:22,082
array five events and if you ever use

1397
01:12:19,097 --> 01:12:26,105
anything like that in your code shame on

1398
01:12:22,082 --> 01:12:27,173
you all right so there you go

1399
01:12:27,005 --> 01:12:30,014
so that's now you know now you

1400
01:12:28,073 --> 01:12:33,074
understand pointers simplest can be and

1401
01:12:30,095 --> 01:12:36,095
all you need is page 53 of knr is a

1402
01:12:33,074 --> 01:12:37,136
handy reference all right so let's we'll

1403
01:12:36,095 --> 01:12:40,142
take the last five minutes and I'll show

1404
01:12:38,036 --> 01:12:43,088
you some some of the ways you can trip

1405
01:12:41,042 --> 01:12:46,061
yourself up when you're accessing memory

1406
01:12:43,088 --> 01:12:47,093
okay so first it's a classic scanf bug

1407
01:12:46,061 --> 01:12:49,142
you probably just probably all done this

1408
01:12:48,038 --> 01:12:54,071
where you forget to tacit the address of

1409
01:12:50,042 --> 01:12:57,077
a variable instead you pass it the

1410
01:12:54,071 --> 01:13:03,137
address so scanf doesn't know where to

1411
01:12:57,077 --> 01:13:05,102
put the you know put the put the data ok

1412
01:13:04,037 --> 01:13:07,109
another another common mistake is to

1413
01:13:06,002 --> 01:13:09,050
read uninitialized memory so you can't

1414
01:13:08,009 --> 01:13:13,016
really assume that your heap data is

1415
01:13:09,005 --> 01:13:16,070
initialized to zero so here we're we're

1416
01:13:13,079 --> 01:13:17,126
Malachy an array of an int and then

1417
01:13:17,015 --> 01:13:21,086
we're going through and we're doing

1418
01:13:18,026 --> 01:13:24,050
we're updating at this vector this Y

1419
01:13:21,086 --> 01:13:27,101
vector we're reading Y I

1420
01:13:24,005 --> 01:13:31,022
we're taking Y it's why I equal Y I plus

1421
01:13:28,001 --> 01:13:35,056
a IJ times XJ okay so we're using we're

1422
01:13:31,067 --> 01:13:37,148
assuming that Y that malloc returns

1423
01:13:35,056 --> 01:13:40,069
memory that's all zeros so that'll get

1424
01:13:38,048 --> 01:13:40,069
you

1425
01:13:42,028 --> 01:13:47,080
it's also easy to allocate the wrong

1426
01:13:45,013 --> 01:13:53,071
sized object so here we want to create

1427
01:13:47,008 --> 01:13:55,105
an array of end pointers of n pointers

1428
01:13:53,071 --> 01:13:58,114
to ends okay and then for each one we

1429
01:13:56,077 --> 01:14:00,115
want to allocate em in all right so this

1430
01:13:59,014 --> 01:14:06,108
work we're creating a two-dimensional

1431
01:14:01,015 --> 01:14:06,108
array and can you see the mistake which

1432
01:14:09,026 --> 01:14:21,054
which line is buggy this one this one or

1433
01:14:18,009 --> 01:14:24,042
this one the first one right because we

1434
01:14:21,054 --> 01:14:25,107
really want size events are right so

1435
01:14:24,042 --> 01:14:28,053
we're we're erroneous incorrectly

1436
01:14:26,007 --> 01:14:33,084
assuming that intz are the same sizes as

1437
01:14:28,053 --> 01:14:35,058
pointers this is a classic on this

1438
01:14:33,084 --> 01:14:37,086
assumption is true for 32-bit code and

1439
01:14:36,003 --> 01:14:40,080
pointers are the same size but it's not

1440
01:14:38,004 --> 01:14:43,050
true for 64-bit and so this is why when

1441
01:14:40,008 --> 01:14:46,020
you when you port when people port

1442
01:14:43,005 --> 01:14:48,009
32-bit code to 64-bit machine a lot of

1443
01:14:46,092 --> 01:14:52,104
times it breaks because they have this

1444
01:14:48,054 --> 01:14:56,106
assumption ok another way it's easy to

1445
01:14:53,004 --> 01:14:59,052
overwrite memory so here we're creating

1446
01:14:57,006 --> 01:15:01,625
correctly creating this array but then

1447
01:14:59,052 --> 01:15:04,128
when we create each of the each of the

1448
01:15:01,679 --> 01:15:07,080
sub arrays instead of I less than or

1449
01:15:05,028 --> 01:15:08,100
equal to n we're actually we only

1450
01:15:07,008 --> 01:15:10,083
created n of these things but we're

1451
01:15:09,000 --> 01:15:12,081
traversing n plus 1 because of this

1452
01:15:10,083 --> 01:15:16,140
lesson are equal so this is a classic

1453
01:15:12,081 --> 01:15:18,135
off by one bug ok another another

1454
01:15:17,004 --> 01:15:20,723
problem you saw it with the code

1455
01:15:19,035 --> 01:15:24,042
injection attacks from your attack lab

1456
01:15:21,119 --> 01:15:27,650
not checking the the size of a buffer so

1457
01:15:24,042 --> 01:15:30,134
get get as is a classic example of this

1458
01:15:27,065 --> 01:15:30,134
so that will get you into trouble

1459
01:15:31,083 --> 01:15:35,088
another another classic mistake is

1460
01:15:33,009 --> 01:15:41,024
misunderstanding pointer arithmetic all

1461
01:15:36,033 --> 01:15:44,040
right so if you incremental pointer then

1462
01:15:42,005 --> 01:15:47,100
it point is incremented by the size of

1463
01:15:45,003 --> 01:15:50,612
the object that pointer points to right

1464
01:15:48,000 --> 01:15:53,006
so if you increment an int star by one

1465
01:15:50,639 --> 01:15:57,050
it actually increments it by four

1466
01:15:53,006 --> 01:15:56,105
because that's the size of an int

1467
01:15:57,062 --> 01:16:03,104
got that's a really important

1468
01:15:59,033 --> 01:16:05,129
distinction and so people often so here

1469
01:16:04,004 --> 01:16:08,048
it's assuming that incrementing so P is

1470
01:16:06,029 --> 01:16:09,128
the pointer and the programmer here

1471
01:16:08,048 --> 01:16:12,083
assumed that he wants to increment the

1472
01:16:10,028 --> 01:16:14,042
pointer to sort of traverse an array so

1473
01:16:12,083 --> 01:16:17,120
he he doesn't understand pointer

1474
01:16:14,042 --> 01:16:21,059
arithmetic and so to get to the next in

1475
01:16:18,002 --> 01:16:23,069
increments P by size event okay this

1476
01:16:21,059 --> 01:16:28,142
will really increment it by sixteen not

1477
01:16:23,087 --> 01:16:31,172
but four okay overriding memory that's a

1478
01:16:29,042 --> 01:16:34,091
really nasty one and a lot of times this

1479
01:16:32,072 --> 01:16:38,087
can happen if you don't understand the

1480
01:16:34,091 --> 01:16:40,115
precedence of the of the operators that

1481
01:16:38,087 --> 01:16:41,150
you're working with so this is a heat

1482
01:16:41,015 --> 01:16:43,022
not not to kind of heap we've been

1483
01:16:42,005 --> 01:16:45,092
talking about but oh the heap data

1484
01:16:43,085 --> 01:16:47,123
structure and this is a this is a

1485
01:16:46,037 --> 01:16:49,073
function to delete from the heat this

1486
01:16:48,023 --> 01:16:54,095
actually is from my own code I have to

1487
01:16:49,073 --> 01:16:58,121
admit and so I wanted to leet I want to

1488
01:16:54,095 --> 01:17:00,128
delete an element I want to delete the

1489
01:16:59,021 --> 01:17:03,116
first element of the heap right and then

1490
01:17:01,028 --> 01:17:05,114
I want to reheat the fly it okay so I

1491
01:17:04,016 --> 01:17:08,093
and then I want to return I want to

1492
01:17:06,014 --> 01:17:14,060
return that so I I get the first element

1493
01:17:08,093 --> 01:17:16,142
the heap I that the size of the heap or

1494
01:17:14,006 --> 01:17:22,088
I take the last element and make that

1495
01:17:17,042 --> 01:17:25,076
the first element and and now I want to

1496
01:17:23,042 --> 01:17:27,113
decrease the size of the heat because

1497
01:17:25,076 --> 01:17:30,122
this delete operation will delete the

1498
01:17:28,013 --> 01:17:33,107
heap size by one so notice here we

1499
01:17:31,022 --> 01:17:35,120
passed size n as a pointer and when this

1500
01:17:34,007 --> 01:17:37,076
when this function terminate when this

1501
01:17:36,002 --> 01:17:40,094
function returns size should be updated

1502
01:17:37,076 --> 01:17:41,114
dated size of the pointer the value that

1503
01:17:41,012 --> 01:17:44,093
it points to you should be decremented

1504
01:17:42,014 --> 01:17:46,067
okay that's our intent and we do it

1505
01:17:44,093 --> 01:17:47,099
right here with the size minus minus

1506
01:17:46,067 --> 01:17:51,146
star so what we want to do is we want to

1507
01:17:48,053 --> 01:17:57,125
dereference size and then decrement that

1508
01:17:52,046 --> 01:18:01,088
value but because the unary minus minus

1509
01:17:58,025 --> 01:18:04,043
has higher precedence than then the

1510
01:18:01,088 --> 01:18:06,107
dereference what we're really doing is

1511
01:18:04,043 --> 01:18:08,138
we're decrementing the pointer and then

1512
01:18:07,007 --> 01:18:14,075
be referencing the value that's

1513
01:18:09,038 --> 01:18:16,109
one word less than our size variable all

1514
01:18:14,075 --> 01:18:20,254
right so these are nasty and it would

1515
01:18:17,009 --> 01:18:23,084
have been much cleaner if I just put

1516
01:18:20,929 --> 01:18:27,770
parentheses around like I intended just

1517
01:18:23,084 --> 01:18:28,109
parentheses star sized parentheses all

1518
01:18:27,077 --> 01:18:30,152
right another another way you can mess

1519
01:18:29,009 --> 01:18:33,092
up is referencing forgetting the local

1520
01:18:31,052 --> 01:18:35,126
variables disappear so if you have a

1521
01:18:33,092 --> 01:18:38,177
function that returns an address of a

1522
01:18:36,026 --> 01:18:42,385
local variable no good okay no good at

1523
01:18:39,077 --> 01:18:44,156
all it might be okay for a while until

1524
01:18:42,619 --> 01:18:47,960
somebody another function reuses that

1525
01:18:45,056 --> 01:18:49,735
space it could be a return address it

1526
01:18:47,096 --> 01:18:54,985
could be another another functions local

1527
01:18:50,239 --> 01:18:57,590
variable another terrible mistake that's

1528
01:18:55,849 --> 01:19:00,530
a really bad one is freeing a block

1529
01:18:57,059 --> 01:19:01,918
multiple time now you know from from

1530
01:19:00,053 --> 01:19:04,492
your understanding now as malloc that

1531
01:19:02,449 --> 01:19:06,478
free actually writes to the heap right

1532
01:19:04,969 --> 01:19:09,980
it's coalescing it's changing pointers

1533
01:19:06,739 --> 01:19:11,750
it's changing size block sizes so if you

1534
01:19:09,098 --> 01:19:16,127
free a block that's already been freed

1535
01:19:11,075 --> 01:19:18,274
terrible things will happen another

1536
01:19:17,027 --> 01:19:20,206
thing you can do wrong is to reference a

1537
01:19:18,949 --> 01:19:22,190
block you forget that you freed a block

1538
01:19:20,449 --> 01:19:24,514
and then you reference it so here we

1539
01:19:22,019 --> 01:19:28,115
free of this block X and then we're

1540
01:19:25,099 --> 01:19:31,610
referencing it here another another big

1541
01:19:29,015 --> 01:19:34,073
problem is memory leaks so failing to

1542
01:19:31,061 --> 01:19:36,107
free block so allocating some block in a

1543
01:19:34,073 --> 01:19:37,148
function and then returning that block

1544
01:19:37,007 --> 01:19:40,806
will stay there forever right because

1545
01:19:38,048 --> 01:19:40,437
it's garbage

1546
01:19:42,058 --> 01:19:47,083
okay so there's a there's a number of

1547
01:19:45,062 --> 01:19:49,411
ways to deal with memory bugs gdb is

1548
01:19:47,083 --> 01:19:51,170
sometimes good at least it'll tell you

1549
01:19:49,969 --> 01:19:55,160
where a seg fault occurs then you gotta

1550
01:19:52,007 --> 01:19:58,043
track down what the right that sort of

1551
01:19:55,016 --> 01:20:01,088
caused that seg fault the best thing you

1552
01:19:59,006 --> 01:20:04,100
can do but gdb falls down whenever

1553
01:20:01,088 --> 01:20:05,089
you're doing manipulation of complex

1554
01:20:05,000 --> 01:20:08,018
data structures

1555
01:20:05,089 --> 01:20:09,110
it's just simple sort of looking one

1556
01:20:08,018 --> 01:20:12,077
instruction at a time what you really

1557
01:20:10,001 --> 01:20:15,007
need to do is identify any complex data

1558
01:20:12,077 --> 01:20:16,139
structure like a heap for example is

1559
01:20:15,016 --> 01:20:18,107
identify invariance for that structure

1560
01:20:17,039 --> 01:20:21,388
that that data structure should always

1561
01:20:19,007 --> 01:20:23,105
maintain and then you write a function

1562
01:20:21,739 --> 01:20:25,850
that iterates over that structure that

1563
01:20:24,005 --> 01:20:28,070
data structure and checks that all those

1564
01:20:25,085 --> 01:20:32,117
invariants are true so for example in it

1565
01:20:28,007 --> 01:20:35,018
and in allocator one of the invariance

1566
01:20:33,017 --> 01:20:37,043
is that there should be no there should

1567
01:20:35,081 --> 01:20:39,104
never be two contiguous free blocks

1568
01:20:37,043 --> 01:20:41,078
right so your your consistency checker

1569
01:20:40,004 --> 01:20:46,006
should go through the heat and make sure

1570
01:20:41,078 --> 01:20:47,084
there's no no contiguous free blocks or

1571
01:20:46,006 --> 01:20:50,014
another invariant is that every free

1572
01:20:48,038 --> 01:20:52,106
block should be in a free list somewhere

1573
01:20:50,014 --> 01:20:54,107
right so you would you would you would

1574
01:20:53,006 --> 01:20:56,012
up your consistency checker would scan

1575
01:20:55,007 --> 01:20:58,064
the heap count the number of free blocks

1576
01:20:56,066 --> 01:20:59,162
and then scan the free list and make

1577
01:20:58,064 --> 01:21:01,073
sure that the number of blocks in the

1578
01:21:00,062 --> 01:21:04,079
free list is the same as the number of

1579
01:21:02,054 --> 01:21:05,117
free blocks okay so this idea of a

1580
01:21:04,079 --> 01:21:06,176
consistency checker is something you'll

1581
01:21:06,017 --> 01:21:09,098
use in your malloc lab but it's

1582
01:21:07,076 --> 01:21:11,078
something it's also something you should

1583
01:21:09,098 --> 01:21:14,189
you should use whenever you're updating

1584
01:21:11,096 --> 01:21:17,120
any kind of complex data structure and

1585
01:21:15,089 --> 01:21:18,170
the and you know about valgrind but the

1586
01:21:18,002 --> 01:21:22,070
great thing about these deep checkers

1587
01:21:19,007 --> 01:21:25,010
I'm passionate about heat checkers or

1588
01:21:22,088 --> 01:21:27,089
consistency checkers this is a really

1589
01:21:26,000 --> 01:21:30,092
powerful thing about them is you write

1590
01:21:27,089 --> 01:21:31,918
them to run silently they don't print

1591
01:21:30,092 --> 01:21:35,165
anything unless they find that a

1592
01:21:32,719 --> 01:21:38,570
violation of the invariants if you write

1593
01:21:36,065 --> 01:21:40,088
your consistency checker like this then

1594
01:21:38,057 --> 01:21:43,079
you can use it like a probe so your

1595
01:21:40,088 --> 01:21:44,162
program crashes so you do if you use

1596
01:21:43,079 --> 01:21:48,778
this heap checker to do a binary search

1597
01:21:45,062 --> 01:21:51,109
to isolate the cause so you know you put

1598
01:21:49,489 --> 01:21:54,920
your you put your heap checker here

1599
01:21:52,009 --> 01:21:55,034
everything is okay and then later the

1600
01:21:54,092 --> 01:21:56,165
program

1601
01:21:55,034 --> 01:22:01,040
Crash's so now you stick the Heep

1602
01:21:57,065 --> 01:22:03,904
checker here and now I crash the Heep

1603
01:22:01,004 --> 01:22:06,029
checker detection in violation so you

1604
01:22:04,489 --> 01:22:07,760
know that the problem is somewhere here

1605
01:22:06,065 --> 01:22:09,131
and you can just keep narrowing it down

1606
01:22:07,076 --> 01:22:11,153
so it's just like a probe surgical probe

1607
01:22:10,031 --> 01:22:16,570
that you can use to to track down bugs

1608
01:22:12,053 --> 01:22:17,150
and so that if you do this like it's I

1609
01:22:16,849 --> 01:22:21,882
don't know how anybody debugs now like

1610
01:22:18,005 --> 01:22:21,684
without this kind of tool

1611
01:22:24,021 --> 01:22:31,118
okay so that's it for today have a good

1612
01:22:28,008 --> 01:22:31,046
weekend we'll see you on Tuesday

